# 재귀 함수란?

자기 자신을 다시 호출하는 함수이다.
재귀 함수의 핵심 특징은 다음과 같다.

재귀함수를 사용하는 경우 함수 호출이 계속해서 쌓이기 때문에 호출 스택이 많아져서 성능이 저하될 수 있습니다. 
따라서 재귀함수를 작성할 때는 무한루프에 빠지지 않도록 종료 조건을 명확하게 설정해주어야 합니다.

호출 과정에서 스택(Stack) 메모리를 사용한다
종료 조건이 없거나 잘못되면,
재귀 호출은 무한히 반복되며 StackOverflowError를 발생시킨다.


### 호출 스택(Call Stack)이란?

- 프로그램에서 함수나 메서드를 호출할 때 
해당 함수나 메서드의 실행이 끝날 때까지 실행되는 
다른 함수나 메서드의 호출 정보를 저장하는 자료구조입니다.

### 재귀 함수를 활용한 예시

import java.util.*;

class Node {
    String name;
    List<Node> children = new ArrayList<>();
    Node(String name) { this.name = name; }
}

public class Main {
    static void print(Node n) { // 재귀 함수
        System.out.println(n.name);
        for (Node c : n.children) print(c); // 재귀 호출
    }

    public static void main(String[] args) {
        Node root = new Node("CEO");
        Node dev = new Node("Dev");
        Node qa = new Node("QA");
        root.children.add(dev);
        root.children.add(qa);
        dev.children.add(new Node("Dev1"));

        print(root); // 재귀함수 호출
    }
}

[구조]
print(CEO)
├─ print(Dev)
│   └─ print(Dev1)
└─ print(QA)


print(root)처럼 메서드를 호출하면 JVM은 **새 스택 프레임(Stack Frame)**을 만듭니다.
스택 프레임에는 지역 변수, 매개변수, 반환 주소가 들어 있어요.

메서드가 끝나면(재귀 호출이 더 이상 없으면)
→ JVM이 해당 스택 프레임을 자동으로 제거합니다.

이전 호출(호출한 쪽)으로 제어가 돌아갑니다.
즉 LIFO 구조: 마지막에 호출된 메서드가 먼저 끝나고 제거



### 재귀 예제
1. 팩토리얼
int factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}


2. 피보나치 수열 – 재귀의 한계
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n - 1) + fib(n - 2);
}

[문제점]
* 같은 계산을 여러 번 반복
* 시간 복잡도: O(2ⁿ)
* 호출 깊이가 깊어질수록 StackOverflow 위험

“재귀는 항상 좋은 선택이 아니다” 를 보여주는 대표 예제
→ 반복문 또는 메모이제이션(DP) 필요

3. 유클리드 호제법 – 재귀가 가장 자연스러운 경우
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

* 수학적 정의 자체가 재귀 구조
* 호출 깊이가 매우 짧음
* 실무에서도 안전하게 사용 가능

4. 이항계수 – 재귀 트리 구조 이해
int comb(int n, int r) {
    if (r == 0 || n == r) return 1;
    return comb(n - 1, r - 1) + comb(n - 1, r);
}

* 재귀 호출 트리가 눈에 보임
* 분할 정복 사고
* 중복 호출 발생 → DP로 확장 가능

재귀는 스택·메모리·성능을 함께 고려해야 하는 선택이다.

재귀 호출과 메모리 (JVM 관점)
재귀 호출 시 스택에서 일어나는 일

메서드가 호출될 때마다 JVM은
스택 프레임(Stack Frame) 을 생성한다.

스택 프레임에는 다음 정보가 저장된다.
* 지역 변수
* 매개변수
* 반환 주소
* 연산 중간 값

피보나치 예시 – fib(5)
| fib(5) |
| fib(4) |
| fib(3) |
| fib(2) |
| fib(1) |

호출될수록 스택 프레임이 쌓임
메서드 종료 시 LIFO 구조로 제거

### StackOverflowError는 왜 발생할까?
void overflow() {
    overflow();
}

* 종료 조건 없음
* 스택 프레임 무한 생성
* 스택 메모리 한계 도달 → 오류 발생

- StackOverflowError는 힙이 아니라 스택 메모리 부족으로 발생한다


### 재귀 vs 반복문 (메모리 관점)
구분	재귀	반복문
메모리 사용	스택 프레임 다수	거의 없음
위험성	StackOverflow	낮음
JVM 부담	큼	작음

- 그래서 자바 실무에서는 반복문이 더 선호된다.

### 꼬리 재귀(Tail Recursion)와 자바의 한계
int sum(int n, int acc) {
    if (n == 0) return acc;
    return sum(n - 1, acc + n); // 꼬리 재귀
}

재귀 호출이 메서드의 마지막 연산
하지만 자바는 꼬리 재귀 최적화(TCO)를 지원하지 않음
스택 프레임은 계속 쌓인다

- 자바는 꼬리 재귀 최적화를 하지 않는다

### 힙 메모리와 재귀의 관계
void recursive(int n) {
    List<Integer> list = new ArrayList<>(); // 힙 메모리
    if (n == 0) return;
    recursive(n - 1);
}


재귀 호출 → 스택 메모리
객체 생성 → 힙 메모리

재귀 + 객체 생성 조합은
스택 + 힙 메모리 모두 압박


### 재귀 호출과 스택 메모리

반복문
┌────────┐
│ stack  │ ← 거의 고정
└────────┘

재귀
┌────────┐
│ stack  │
│ stack  │
│ stack  │ ← 깊어질수록 증가
└────────┘

재귀 호출은 호출 스택 위에 프레임을 계속 쌓아가는 구조다.
자바에서는 스택 한계를 고려해 반복문이나 다른 대안을 함께 검토해야 한다.




참고
https://data-marketing-bk.tistory.com/entry/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4-%EB%B0%8F-%EA%B5%AC%ED%98%84Recursive-Function
https://adjh54.tistory.com/194