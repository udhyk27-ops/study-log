상속(extends)이란?
기존 클래스의 구조와 동작을 물려받아 새로운 클래스를 만드는 객체지향 개념

상속은 공통된 속성과 동작을 부모 클래스에 정의하고,
자식 클래스가 이를 재사용하거나 일부를 확장 및 변경할 수 있게 하는 관계이다.

상속을 사용하는 시점
상속은 구조가 장기간 안정적일 때 사용한다.
개념적으로 같은 종류이고 공통 구조 + 동작이 명확할 때 사용
부모 클래스 정의
public abstract class AbstractExcelExport { // 공통 틀 제공 (abstract)

    // 전체 실행 흐름을 부모 클래스에서 고정
    // 자식이 흐름을 바꾸지 못하도록 설계 (final)
    public final void export() {
        validate();
        List<String> data = getData();   // 자식이 결정
        writeExcel(data);                // 공통 로직
        afterExport();
    }

    protected void validate() { // 자식 클래스에서 override 가능
        System.out.println("공통 검증");
    }

    protected abstract List<String> getData(); // 데이터는 자식 클래스가 결정

    protected void writeExcel(List<String> data) {
        System.out.println("엑셀 생성: " + data);
    }

    protected void afterExport() {
        System.out.println("후처리");
    }
}

자식 클래스 1
import java.util.List;

public class UserExcelExport extends AbstractExcelExport {

    @Override
    protected List<String> getData() { // override
        return List.of("user1", "user2");
    }
}

자식클래스 2
import java.util.List;

public class OrderExcelExport extends AbstractExcelExport {

    @Override
    protected List<String> getData() { // override
        return List.of("orderA", "orderB");
    }
}

외부 호출
public class Main {
    public static void main(String[] args) {
        AbstractExcelExport export1 = new UserExcelExport();
        AbstractExcelExport export2 = new OrderExcelExport();

        export1.export();
        export2.export();
    }
}
이처럼 기본 동작이 명확한 경우,
부모 클래스에서 전체 흐름을 먼저 정의해두고
자식 클래스는 어떤 데이터를 가져올지만 구현하도록 하면 구조가 훨씬 단순해진다.

부모 클래스가 처리 순서를 정해주기 때문에 자식 클래스는 공통 로직을 신경 쓰지 않아도 되고,
실수로 흐름을 깨뜨릴 가능성도 줄어든다.

다만 상속은 부모와 자식이 강하게 묶이는 구조이기 때문에,
공통 구조와 동작이 분명하고 해당 설계가 자주 바뀌지 않을 때에만 사용하는 것이 좋다.

의존(implements)이란?
의존은 한 클래스가 다른 클래스의 기능을 사용해야 할 때 생기는 관계다. 

객체 A입장에서 객체 B의 존재를 알고 있을 때
"객체 A는 객체 B에 의존성을 가지고 있다." 라고 표현한다.


의존을 사용하는 시점
서로 다른 역할을 수행하는 객체를 사용해야 하고, 해당 구현체의 교체 가능성이 있을 때 의존 관계를 사용한다.
Payment 인터페이스에서 역할 정의
CardPayment 클래스에서 역할 구현
interface Payment {
    void pay(int amount);
}

class CardPayment implements Payment {
    public void pay(int amount) {
        System.out.println("카드 결제");
    }
}


결제 인터페이스를 의존하여
클래스에서 결제 기능을 직접 구현하지 않고 사용한다.
class OrderService {
    private final Payment payment; // 의존

    OrderService(Payment payment) {
        this.payment = payment;
    }

    void order(int amount) {
        payment.pay(amount);
    }
}

Payment 인터페이스는 결제를 수행하기 위해 pay() 메서드가 필요하다는 규칙을 정의한다.

이를 구현한 CardPayment와 같은 클래스에서는
각 결제 수단에 맞는 구체적인 로직을 통해 pay() 메서드를 어떻게 수행할지 정의한다.

OrderService 클래스는 결제 과정의 내부 구현은 알지 못하지만, 의존성을 주입받아 결제 기능을 사용할 수 있다.

즉, 결제 로직을 직접 구현하는 것이 아니라 필요한 기능을 외부에서 빌려 사용하는 구조다.

상속과 의존의 차이

상속은 같은 종류의 객체일 때 사용하는 관계다.

부모 클래스에서 공통 구조와 동작을 정의하고, 자식 클래스는 이를 물려받아 확장한다.
공통된 흐름을 강제할 수 있지만, 부모와 자식이 강하게 결합된다는 특징이 있다.


의존은 다른 역할을 수행하는 객체의 기능을 사용할 때 사용하는 관계다.
구현이 무엇인지는 중요하지 않고, 해당 기능을 수행할 수 있다는 사실만 알면 된다.

이로 인해 구현체 교체가 쉽고 구조가 유연해진다.

상속은 구조를 공유하고 강제할 때, 의존은 기능을 빌려 사용할 때 적합하다.


상속과 의존을 실제로 사용한다면

같은 종류의 객체인지를 본다.
개념적으로 같은 계열이라면 상속을 고려할 수 있다.
반대로 같은 종류가 아니라면 상속은 피하고 의존 관계로 푸는 게 맞다.

다음으로 구현체가 바뀔 가능성이 있는지를 생각한다.
결제 방식, 저장소, 외부 연동처럼
언젠가 교체될 가능성이 있다면 interface를 두고 의존성을 주입(DI)하는 방식이 적합하다.

마지막으로 공통 로직의 존재 여부다.
여러 구현체에서 공통으로 사용하는 코드가 있다면 abstract class가 적합하고,
단순히 “이런 기능이 필요하다”라는 규칙만 있다면 interface로 충분하다.
프로그래밍에서 상속보다 합성을 권하는 이유


합성(Composition)은 클래스를 상속하는 대신,
다른 객체를 필드로 포함해서 기능을 조합하는 설계 방식이다.

Car는 Engine을 상속하지 않는다.
필드로 가지고 있으면서 필요한 기능만 사용한다.
class Engine {
    void start() {
        System.out.println("엔진 시동");
    }
}

class Car {
    private final Engine engine; // 합성

    Car(Engine engine) {
        this.engine = engine;
    }

    void drive() {
        engine.start(); // 기능을 빌려서 사용
        System.out.println("자동차 주행");
    }
}

코드 형태는 의존성 주입과 비슷해 보이지만,
개념적으로는 서로 다른 개념이다.

합성은
객체를 어떤 객체로 구성할 것인지에 대한 설계 방식이고,

의존성 주입은
그 객체를 누가, 어디서 생성해서 전달할 것인지에 대한 방법이다.

합성은 구조의 문제이고,
의존성 주입은 책임의 문제다.

Car는 Engine을 직접 생성하지 않고 DI로 주입받으며,
내부에서는 Engine을 합성 관계로 사용한다.
Engine engine = new Engine(); // 외부에서 생성
Car car = new Car(engine);    // 주입
참고
https://inpa.tistory.com
https://travelof-fnqk.tistory.com/entry/상속과-의존성-주입
https://6mini.github.io/object%20oriented%20programming/2022/09/18/dependency/