1. 자바

Java의 특징을 설명해 주세요.
객체지향 프로그래밍
자동 메모리 관리(가비지 컬렉션)
플랫폼 독립성
Java의 컴파일 과정에 대해 설명해 주세요.
개발자가 .java 파일을 생성하고 빌드한다.
자바 컴파일러가 javac 명령어로 바이트코드(.class)를 생성
Class Loader를 통해 JVM 메모리 내로 로드
실행 엔진이 각 운영체제에 맞는 기계어로 변환
클래스와 객체에 대해 설명해 주세요.
클래스는 객체를 만들어내는 틀 (붕어빵)
new 키워드를 사용하여 객체를 생성하면 메모리에 저장되고, 메모리 주소는 참조변수에 저장
생성자(Constructor)에 대해 설명해 주세요.
객체 생성 시 한 번만 호출되며, 인스턴스 변수를 초기화
클래스와 같은 이름의 메소드로, 반환형이 없으며, 파라미터를 달리하여 오버로딩 가능
기본 생성자가 없을 경우, 자바 컴파일러가 자동으로 삽입
this
현재 인스턴스인 자신을 가리키는 키워드
super
상위 클래스의 생성자를 호출하는 키워드
하위 클래스의 생성자는 상위 클래스 생성자를 먼저 호출해야 함
final, finally, finalize의 차이를 설명해 주세요.
final: 변수는 한 번 초기화되면 변경 불가
finally: 예외 처리 구문에서 예외 발생 여부와 관계없이 실행
finalize: 객체가 가비지 컬렉션될 때 호출
static에 대해 설명해 주세요.
클래스가 메모리에 올라갈 때 자동 생성, 인스턴스 생성 없이 사용 가능
static 변수: 참조의 용도, 공용자원에 대한 접근
static 메서드: 단순히 외부에 기능을 제공할 때
인터페이스와 추상 클래스의 차이점
다형성: 추상 클래스와 인터페이스 모두 다형성을 지원, 여러 클래스가동일한 인터페이스나 상위 클래스로취급될 수 있는 능력을 의미, 이는 코드의 유연성을 높이고 재사용성을 증가
추상 메서드: 추상 클래스는 일부 구현된 메서드를 가질 수 있지만, 인터페이스는 모든 메서드가 추상 메서드여야 함
상속: 추상 클래스는 하위 클래스가 상위 클래스의 특성과 동작을 상속받을 수 있도록 하며, 인터페이스는 클래스가 특정 동작을 구현하도록 강제
다중: 클래스는 하나의 클래스만 상속 가능하지만, 인터페이스는 다중 상속 가능
오버라이딩과 오버로딩에 대해 설명해 주세요.
오버라이딩: 상위 클래스의 메서드를 하위 클래스에서 재정의
오버로딩: 매개변수의 개수나 타입을 달리하여 동일한 이름의 메서드를 여러 개 정의
Synchronized에 대해 설명해 주세요.
여러 스레드가 하나의 자원을 동시에 사용하지 못하도록, 현재 데이터를 사용 중인 스레드를 제외하고 다른 스레드의 접근을 막음
Synchronized를 남용하면 성능 저하가 발생할 수 있음
String, StringBuffer, StringBuilder의 차이점을 설명해 주세요.
String: 불변 객체 (immutable)
StringBuffer: 가변 객체, 동기화 지원 (멀티 스레드 환경 적합)
StringBuilder: 가변 객체, 동기화 미지원 (싱글 스레드 환경 적합)
컬렉션 프레임워크에 대해 설명해 주세요.
컬렉션 프레임워크는 데이터를 관리하는 표준화된 클래스 집합
제네릭: 구체적인 데이터 타입을 미리 지정하지 않고, 나중에 사용할 때 해당 타입을 지정할 수 있게 하는 기능입니다.
ArrayList: 동적 크기를 가진 배열 기반 리스트, 빠른 액세스와 순차 접근 가능
LinkedList: 더블 링크드 리스트로 구현, 요소 추가/제거가 빠름
HashSet: 중복을 허용하지 않는 집합, 해시 테이블 기반
HashMap: 키-값 쌍으로 데이터를 저장하는 맵, 빠른 검색과 삽입 가능
CheckedException과 UnCheckedException의 차이점을 설명해 주세요.
CheckedException: 컴파일 시 반드시 처리해야 하는 예외 (예: SQLException)
UncheckedException: 런타임 시 발생하는 예외로, 컴파일 시 처리하지 않아도 되는 예외 (예: NullPointerException)
활용: 체크 예외는 비즈니스 로직에서 의도적으로 발생시키고, 언체크 예외는 복구할 수 없는 시스템 오류에 사용
2. 스프링

Spring Framework 설명
IoC(제어의 역전): 객체 생성과 관리의 제어권이 프레임워크에 있음.
DI(의존성 주입): 프레임워크가 객체 간 의존성을 자동으로 주입.
AOP(관점 지향 프로그래밍): 공통 기능(로깅, 트랜잭션 등)을 분리해 모듈화.
Spring Boot와 Spring Framework의 차이점
Spring Framework: 다양한 환경 설정이 필요함.
Spring Boot: 설정을 자동화해 편리하게 스프링을 활용할 수 있으며, 내장된 톰캣을 통해 서버를 바로 실행 가능.
스프링의 요청 처리 흐름
DispatcherServlet: 클라이언트 요청을 받아 전체 처리 과정을 통제.
HandlerMapping: 요청 URL에 따라 적합한 컨트롤러 결정.
HandlerAdapter: 결정된 컨트롤러 메서드를 호출.
ViewResolver: 처리 결과를 보여줄 view를 결정.
Spring MVC 설명
MVC 패턴: Model(데이터), View(화면), Controller(요청 처리)로 구성.
Controller: 사용자 요청 처리 및 모델과 뷰 중개.
Model: 비즈니스 로직 처리 및 데이터 관리.
View: 처리 결과를 thymeleaf, JSON 등으로 응답.
VO, BO, DAO, DTO 설명
DAO: DB 접근을 담당하는 객체.
DTO: 계층 간 데이터 전송을 위한 객체.
VO: 데이터만을 담는 객체.
Spring의 싱글톤 패턴
모든 클라이언트가 동일한 객체 인스턴스를공유. 필드는 읽기 전용으로 사용해야 함.
스프링에서 빈(Bean) 등록 방법
@Component 어노테이션을 사용해 빈 등록.
@Configuration과 @Bean을 사용해 빈을 수동으로 등록 가능.
@RequestBody, @RequestParam, @ModelAttribute의 차이점
@RequestBody: JSON 형태의 HTTP Body를 Java 객체로 변환.
@RequestParam: 단일 HTTP 요청 파라미터를 받음.
@ModelAttribute: HTTP Body와 파라미터 값을 객체에 바인딩.
Spring Filter와 Interceptor 차이
웹과 관련된 공통 관심사를 해결하기 위한 기술
HTTP 요청 -> WAS -> 필터 -> 서블릿(Dispatcher Servlet) -> 인터셉터 -> 컨트롤러
@Transactional의 동작 원리
@Transactional이 있는 클래스나 메서드에 대해 스프링은 프록시 객체를 만들어 스프링 빈에 등록하고,
프록시 객체는 요청을 먼저 받아 트랜잭션을 관리한 후, 실제 객체를 호출하여 작업을 수행
한계: 메서드 내부 호출에는 트랜잭션 적용이 어려움.
해결방법: 해당 메서드를 별도의 클래스로 분리하여 처리
@Transactional의 readOnly 속성
읽기 전용 트랜잭션에 사용.
엔티티를 관리하지 않음으로써 메모리 성능을 향상시키고,
코드 가독성 증가.
3. 데이터베이스

SELECT 쿼리의 수행 순서
FROM → ON → JOIN →
WHERE → GROUP BY → HAVING →
SELECT → DISTINCT →
ORDER BY → LIMIT
Index란 무엇이며, 장단점
Index: 테이블 전체를 검색하지 않고, 인덱스를 통해 필요한 데이터에 빠르게 접근하는 방법.
장점: 검색 속도 향상
단점: 데이터 추가, 수정, 삭제 시 성능 저하
DBMS에서 Index 관리 방식 (자료구조)
B+Tree 구조를 사용해 인덱스 관리.
BTree의 리프 노드들이 LinkedList로 연결되어 있어 순차 검색이 용이함.
정규화란?
하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하고,
중복을 최소화하여 데이터를 논리적으로 저장하는 과정.
역정규화의 이유
정규화 후 JOIN 연산이 많아지면 성능 저하가 발생할 수 있어, 성능 개선을 위해 역정규화를 수행함.
SQL Injection이란?
공격자가 SQL 구문에 악의적인 코드를 삽입해 데이터베이스를 비정상적으로 조작하는 공격 기법.
SQL Injection 방어 및 방지 방법
입력값 검증: 사용자 입력값을 철저히 검증해 의도치 않은 쿼리 실행을 방지.
저장 프로시저 사용: 쿼리문을 동적으로 생성하지 않도록 한다.
옵티마이저(Optimizer)란?
SQL을 실행하기 전에, 최적의 실행 계획을 수립하여 쿼리를 효율적으로 수행하는 엔진.
Clustered Index와 NonClustered Index
Clustered Index:
테이블의 데이터가 실제로 인덱스의 리프 노드에 저장되어,
인덱스 순서에 따라 물리적으로 데이터가 정렬됩니다.
테이블당 한 개만 생성 가능 (프라이머리 키).
NonClustered Index:
데이터는 별도 저장되며,
인덱스 페이지에서 위치 포인터를 통해 참조.
여러 개 생성 가능.
4. 프로그래밍 공통

REST API 요약
API는 URL을 통해 자원을 나타내며, 자원의 행위는 HTTP 메서드로 명시됩니다.
RESTful API는 URL만으로도 요청의 목적을 파악할 수 있습니다.
WAS의 멀티 스레드 지원
개발자는 멀티 스레드를 직접 관리할 필요 없이 싱글 스레드처럼 개발이 가능.
싱글톤 객체(서블릿, 스프링 빈)는 주의하여 사용해야 합니다.
쓰레드 풀
필요 시 미리 생성된 쓰레드를 풀에서 꺼내어 사용 후 반납.
장점: 쓰레드 생성/종료 비용 절약, 빠른 응답 시간.
튜닝 팁: WAS의 주요 튜닝 포인트는 최대 쓰레드 수 (톰캣은 최대 200개 기본 설정)
최대 쓰레드 수가 너무 낮을 때: 동시 요청이 많아지면 서버 리소스는 여유롭지만, 클라이언트 측에서 응답 지연이 발생
최대 쓰레드 수가 너무 높을 때: 동시 요청이 많아지면 CPU 및 메모리 리소스의 임계점이 초과되어 서버가 다운될 수 있습니다.
적정 쓰레드 수 설정: 로직 복잡도, CPU, 메모리, IO 리소스 상황에 따라 결정됩니다.
장애 대응: 
클라우드 환경: 자원 확장 후 튜닝.
비클라우드 환경: 쓰레드 수와 리소스 세밀 조정.
WAS(Web Application Server)와 WS(Web Server)의 차이
WS: HTML, CSS, 이미지 등과 같은 정적인 콘텐츠 제공.
WAS: DB 조회나 비즈니스 로직과 같은 동적 콘텐츠 제공.
Web Server를 WAS 앞에 두는 구조: Load Balancing -> 서버 부담 분산, 무중단 운영
MSA(Microservice Architecture)
1개의 시스템을 독립 배포 가능한 여러 서비스로 분리.
각각의 서비스는 API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성
장점: 일부 서비스 장애에도 전체 시스템 영향이 적음.
단점: 서비스 간 호출 및 트랜잭션 처리 어려움.
서버 사이드 렌더링 vs 클라이언트 사이드 렌더링
서버 사이드 렌더링:
서버에서 HTML을 생성해 제공. (예: JSP, Thymeleaf)
장점: 단순하고 학습이 쉬움.
클라이언트 사이드 렌더링:
서버는 API만 제공, 프론트에서 HTML 동적 생성. (예: React, Vue.js)
장점: 동적이고 복잡한 UI 처리 가능.
Thymeleaf와 JSP의 차이점
JSP: 서버에서 JSP 파일을 컴파일하여 서블릿으로 변환 후 실행, 자바 코드를 포함할 수 있어 비즈니스 로직과 UI 혼합 가능
Thymeleaf: 서버와 상관없이 HTML로 바로 브라우저에서 확인 가능, 비즈니스 로직과 UI가 완전히 분리됨, JAR 패키징 지원, 스프링 부트와 강력한 호환성
크로스 도메인 이슈
동일 출처 정책으로 다른 도메인 간 리소스 요청 제한.
예: https://example.com에서 https://anotherexample.com의 리소스에 접근하려고 하면, 브라우저는 보안상의 이유로 접근을 차단합니다. (AJAX 요청)
CORS 헤더 설정: 서버가 응답 시 특정 도메인에 대해 리소스 접근을 허용하는 HTTP 헤더를 포함해, 클라이언트가 해당 출처의 리소스에 접근할 수 있게 허용합니다.
CSRF(Cross-Site Request Forgery)
공격자가 사용자의 세션 정보를 도용해 악의적인 요청을 보내는 공격 기법.
방지 방법: 서버는 각 요청에 대해 고유한 토큰을 발행하고, 사용자는 요청 시 이 토큰을 함께 전송해야 합니다. 서버는 요청이 수신될 때 토큰을 확인하여 요청이 신뢰할 수 있는 출처에서 온 것인지 검증
XSS(크로스 사이트 스크립팅) 공격 방지 방법
웹 페이지(게시판)에 악성 스크립트 삽입을 통해 사용자 정보를 탈취.
대응 방안: 입력값 검증, 출력 시 인코딩.
SSRF(Server-Side Request Forgery) 공격
내부 서버에 대한 비정상적인 요청을 허용하는 취약점.
내부 네트워크 스캐닝, 민감한 데이터 접근 등
대응 방안:
사용자로부터 받은 입력값을 철저하게 검증하고
허용된 도메인이나 IP 주소로만 요청을 보내도록 제한합니다.
5. 네트워크

HTTP 프로토콜
데이터를 주고받기 위한 상태 정보를 저장하지 않는 프로토콜로,
클라이언트 요청에 응답 후 연결을 끊는 방식.
장점: 각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK
단점: 이전 통신 정보를 기억하지 않아 매번 인증이 필요함(쿠키나 세션 사용으로 해결).
HTTP vs HTTPS
HTTP: 평문 데이터를 전송해 보안에 취약.
HTTPS: SSL을 통해 암호화된 데이터를 전송하여 보안을 강화함.
서버 기반 인증 (Session / Cookie)
서버가 세션을 통해 사용자 정보를 기억하고 인증하며, 세션 정보는 서버의 메모리 등을 통해 관리합니다.
동작방식
사용자가 로그인하면 서버는 사용자 인증을 확인하고, 고유한 세션 ID를 발급합니다.
서버는 세션 ID를 메모리에 저장하고, 클라이언트는 이 세션 ID를 쿠키에 저장합니다.
이후 클라이언트가 요청을 보낼 때마다 쿠키에 담긴 세션 ID를 서버로 전송합니다.
서버는 해당 세션 ID를 세션 저장소와 비교하여 올바른 요청인지 확인한 후, 응답을 보냅니다.
장점: 중요한 정보는 서버에 저장되므로 안전함.
단점: 세션이 서버에 저장되므로 사용자가 많아지면 서버 부하가 증가.
토큰 기반 인증 (JWT)
인증 정보를 서버가 아닌 클라이언트에 저장해 Stateless 구조 유지.
동작 방식:
사용자가 로그인하면 서버가 인증에 필요한 정보를 암호화시킨 토큰을 발급합니다.
클라이언트는 JWT를 저장하고, 요청할 때마다 이 토큰을 HTTP 헤더에 포함해 보냅니다.
서버는 토큰을 복호화하여 요청이 올바른지 확인 후 응답합니다.
단점: JWT는 한 번 발급되면 취소가 불가능하므로, 유효기간을 짧게 설정해야 함.
캐시(Cache)
웹 페이지 요소를 임시로 저장해 빠르게 렌더링하도록 돕는 저장소.
www.naver.com 접속 과정
URL 입력 → DNS 서버에서 IP 주소 조회 → TCP 3-way handshake → HTTP 요청 → HTTP 응답 → 웹 페이지 렌더링.
GET vs POST
GET: URL에 데이터를 노출하며 주로 조회에 사용.
POST: 데이터가 바디에 포함되며 추가/수정에 사용, 보안 측면에서 GET보다 안전.
라우터
IP 주소 할당: 공인 IP 주소는 라우터(공유기)에 할당되며, 내부 네트워크의 장치들(컴퓨터 등)에게 사설 IP 주소를 자동으로 할당
데이터 전달: 상위 네트워크와 하위 네트워크 간의 최적 경로를 찾아 데이터를 전달
IP 주소 변환: NAT 기능을 통해 사설 IP 주소를 공인 IP 주소로 변환하여 여러 장치들이 하나의 공인 IP 주소로 인터넷에 접속할 수 있게 합니다.
네트워크 보안 구성 요소
VPN: VPN 장비로 데이터를 암호화하여 송수신함으로써 공용 네트워크(인터넷)를 안전하게 사용하는 방법.
DMZ: 외부 네트워크에서 접근할 수 있지만, 내부 네트워크와는 분리되어 있어 내부 네트워크로의 직접적인 접근을 차단합니다. (웹 서버)
방화벽: 네트워크 트래픽을 모니터링하고 특정 트래픽의 허용 또는 차단을 결정하는 보안 시스템.