재귀 호출이란?

재귀 호출이란 메서드가 자기 자신을 다시 호출하는 구조를 말한다.

재귀 호출의 핵심 특징은 다음과 같다.

자기 자신을 호출한다

반드시 종료 조건(Base Case)이 있어야 한다

호출 과정에서 스택(Stack) 메모리를 사용한다

종료 조건이 없거나 잘못되면,
재귀 호출은 무한히 반복되며 StackOverflowError를 발생시킨다.

팩토리얼 – 가장 기본적인 재귀 예제
int factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}

설명 포인트

종료 조건이 명확함

재귀 구조를 이해하기 가장 쉬운 예제

실무보다는 개념 설명용으로 적합

👉 재귀의 “형태”를 익히는 데 목적이 있다.

3️⃣ 피보나치 수열 – 재귀의 한계
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n - 1) + fib(n - 2);
}

문제점

같은 계산을 여러 번 반복

시간 복잡도: O(2ⁿ)

호출 깊이가 깊어질수록 StackOverflow 위험

👉 “재귀는 항상 좋은 선택이 아니다” 를 보여주는 대표 예제
→ 반복문 또는 메모이제이션(DP) 필요

4️⃣ 유클리드 호제법 – 재귀가 가장 자연스러운 경우
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

설명 포인트

수학적 정의 자체가 재귀 구조

호출 깊이가 매우 짧음

실무에서도 안전하게 사용 가능

👉 재귀의 좋은 예

5️⃣ 이항계수 – 재귀 트리 구조 이해
int comb(int n, int r) {
    if (r == 0 || n == r) return 1;
    return comb(n - 1, r - 1) + comb(n - 1, r);
}

설명 포인트

재귀 호출 트리가 눈에 보임

분할 정복 사고

중복 호출 발생 → DP로 확장 가능

🧠 정리 (개념 파트 마무리)

재귀는 “편한 문법”이 아니라
스택·메모리·성능을 함께 고려해야 하는 선택이다.

재귀 호출과 메모리 (JVM 관점)
6️⃣ 재귀 호출 시 스택에서 일어나는 일

메서드가 호출될 때마다 JVM은
스택 프레임(Stack Frame) 을 생성한다.

스택 프레임에는 다음 정보가 저장된다.

지역 변수

매개변수

반환 주소

연산 중간 값

피보나치 예시 – fib(5)
| fib(5) |
| fib(4) |
| fib(3) |
| fib(2) |
| fib(1) |


호출될수록 스택 프레임이 쌓임

메서드 종료 시 LIFO 구조로 제거

7️⃣ StackOverflowError는 왜 발생할까?
void overflow() {
    overflow();
}


종료 조건 없음

스택 프레임 무한 생성

스택 메모리 한계 도달 → 오류 발생

💡 면접 포인트

StackOverflowError는 힙이 아니라 스택 메모리 부족으로 발생한다

8️⃣ 재귀 vs 반복문 (메모리 관점)
구분	재귀	반복문
메모리 사용	스택 프레임 다수	거의 없음
위험성	StackOverflow	낮음
JVM 부담	큼	작음

👉 그래서 자바 실무에서는 반복문이 더 선호된다.

9️⃣ 꼬리 재귀(Tail Recursion)와 자바의 한계
int sum(int n, int acc) {
    if (n == 0) return acc;
    return sum(n - 1, acc + n); // 꼬리 재귀
}


재귀 호출이 메서드의 마지막 연산

하지만 자바는 꼬리 재귀 최적화(TCO)를 지원하지 않음

스택 프레임은 계속 쌓인다

💡 면접 포인트

자바는 꼬리 재귀 최적화를 하지 않는다

🔟 힙 메모리와 재귀의 관계
void recursive(int n) {
    List<Integer> list = new ArrayList<>(); // 힙 메모리
    if (n == 0) return;
    recursive(n - 1);
}


재귀 호출 → 스택 메모리

객체 생성 → 힙 메모리

👉 재귀 + 객체 생성 조합은
스택 + 힙 메모리 모두 압박

1️⃣1️⃣ 메모리 관점에서 재귀 사용 기준
👍 써도 괜찮은 경우

깊이가 명확히 제한됨

트리 구조 (DFS)

유클리드 호제법

👎 피해야 할 경우

깊이 예측 불가

단순 반복 로직

대규모 입력

📌 재귀 호출과 스택 메모리 (그림 요약)
반복문
┌────────┐
│ stack  │ ← 거의 고정
└────────┘

재귀
┌────────┐
│ stack  │
│ stack  │
│ stack  │ ← 깊어질수록 증가
└────────┘

🧠 최종 마무리

재귀 호출은 호출 스택 위에
프레임을 계속 쌓아가는 구조다.
자바에서는 스택 한계를 고려해
반복문이나 다른 대안을 함께 검토해야 한다.




참고
https://data-marketing-bk.tistory.com/entry/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4-%EB%B0%8F-%EA%B5%AC%ED%98%84Recursive-Function
https://adjh54.tistory.com/194