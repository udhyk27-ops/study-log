객체지향 프로그래밍이 등장한 배경

프로그래밍 언어의 역사를 보면 초기에는 대부분 절차지향 언어였다.
C 언어나 포트란 같은 언어가 대표적이다.

절차지향에서는 프로그램이 “무엇을 순서대로 처리할지”를 중심으로 작성된다.
함수나 루틴 단위로 코드를 쪼개고
main 함수에서 순서대로 호출하는 구조가 기본이다.

절차지향의 한계

작은 프로그램에서는 문제가 없다.
간단한 계산기, 알고리즘 문제, 스크립트 등은 절차지향으로 충분하다.

하지만 프로그램이 커지면 문제점이 드러난다.

복잡성 증가
코드가 길어지면서 함수와 데이터가 분리돼 있어
어떤 데이터가 어디서 바뀌는지 추적하기 어렵다

재사용 어려움
특정 기능을 다른 프로그램에서 쓰려면
데이터와 함수를 함께 옮겨야 하고
의존성이 많아 쉽게 재사용할 수 없다

유지보수 어려움
수정이 필요할 때 코드가 전체에 영향을 미치기 쉽다
특히 서로 얽힌 데이터와 함수가 많으면 문제는 더 심각하다

현실 세계 모델링의 어려움
사람, 물건, 주문 같은 현실 세계 개념을
함수와 절차만으로 표현하려면 복잡한 코드가 된다

객체지향의 등장

이런 문제를 해결하기 위해 **객체지향 프로그래밍(OOP)**이 등장했다.

객체지향의 핵심 아이디어는 다음과 같다.

데이터와 행동을 하나로 묶는다
사람, 주문, 결제 같은 개념을 객체로 표현
객체 안에 데이터(속성)와 행동(메서드)을 함께 둔다

캡슐화
객체 내부 데이터는 외부에서 직접 접근하지 못하고
메서드를 통해서만 다룬다
→ 데이터 변경이 통제 가능하고 오류 위험 감소

상속
공통 기능을 상위 클래스에 두고
필요한 부분만 하위 클래스에서 확장
→ 코드 재사용과 구조 강제 가능

다형성
같은 역할(인터페이스)을 수행하는 객체를
실행 시점에 바꿔 끼워 넣을 수 있음
→ 변경에 유연하고 테스트가 쉬움

즉 객체지향은

“프로그램을 현실 세계와 비슷하게 모델링하고
복잡성을 관리하며
재사용성과 유지보수를 높이는 방법”으로 등장한 것이다.

실생활 예시

주문 처리 프로그램을 예로 들어보자.

절차지향 방식:

main 함수에서 주문 입력, 결제, 배송, 로그를 순서대로 처리

각 단계마다 여러 함수 호출

데이터가 함수 밖에서 바뀔 수 있어 추적 어려움

객체지향 방식:

주문(Order) 객체, 결제(Payment) 객체, 배송(Delivery) 객체로 나눔

각 객체가 자기 데이터와 행동을 담당

main 함수에서는 객체를 조합하고 호출만 함

요구사항 변경 시 특정 객체만 수정하면 됨

한 문장 요약

객체지향 프로그래밍은
프로그램 복잡성을 관리하고 재사용과 유지보수를 쉽게 하기 위해
데이터와 행동을 하나의 객체로 묶고 현실 세계를 모델링한 프로그래밍 패러다임이다.

절차지향 vs 객체지향 비교표
항목	절차지향	객체지향
중심	함수(프로세스, 로직)	객체(데이터 + 행동)
데이터 처리	함수와 데이터 분리	데이터와 행동을 객체 안에 묶음
코드 재사용	함수 단위 재사용	상속과 다형성으로 재사용
유지보수	코드가 길어지고 의존 많으면 어려움	객체 단위로 책임 분리, 수정 영향 최소화
현실 세계 모델링	어려움, 데이터와 행동이 분리	자연스럽게 모델링 가능
실행 흐름	순차적, main 함수 중심	객체 간 메시지 전달과 상호작용 중심
확장성	어려움, 함수 수정 필요	새로운 객체 추가로 확장 가능
테스트	전체 함수 호출 필요, 독립적 테스트 어려움	객체 단위 테스트 용이
예시	계산기, 단순 스크립트	주문 처리 시스템, 결제 시스템, 서버 애플리케이션
추가 설명

절차지향은 **“무엇을 순서대로 처리할 것인가”**에 집중

객체지향은 **“누가 무엇을 담당할 것인가”**에 집중

복잡한 프로그램일수록 객체지향이 관리와 확장에 유리하다