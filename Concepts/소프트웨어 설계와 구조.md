# 소프트웨어 설계와 구조
소프트웨어 설계는 요구사항을 분석‧해석하여 외부 행동과 내부 구조를 정의하고, 
구현 가능한 명세(SDD)로 변환하는 활동이다. 이는 코딩‧테스트 전(前)단계에서 "어떻게 만들 것인가"를 결정하는 과정이다.

1. 왜 구조 설계를 먼저 고민해야 하는가

2. 소프트웨어는 코드가 아니라 ‘과정’이다

3. 생명주기에서 구조 설계가 영향을 미치는 지점

4. 구조 설계에서 신경 써야 할 핵심 개념
   - 변경 지점
   - 의존성
   - 책임 분리
   
   추상화, 모듈화, 캡슐화, 계층화 구조
   
   
5. 아키텍처는 정답이 아니라 선택이다

6. 작은 프로젝트에서도 구조 설계가 필요한 이유






좋은 구조 설계란,
기능 추가가 두렵지 않은 애플리케이션을 만드는 것이다.

# 소프트웨어 개발 프로세스

소프트웨어 개발 프로세스 – 나선형 모델과 V모델

소프트웨어를 만들 때 단순히 코드를 작성하는 것만으로는 충분하지 않다.
전체 개발 과정을 계획하고 관리하는 개발 프로세스가 필요하다.

이번 글에서는 **나선형 모델(Spiral Model)**과 **V모델(V-Model)**을 살펴본다.

1. 나선형 모델(Spiral Model)

나선형 모델은 반복적 개발과 위험 관리를 동시에 고려한 프로세스다.

특징

반복적 개발: 소프트웨어를 여러 번 나누어 점진적으로 완성

위험 관리 중심: 각 반복마다 위험 요소를 분석하고 대응

점진적 완성: 초기에는 간단한 프로토타입, 점차 완전한 시스템 완성

단계

나선형 모델은 반복 주기마다 다음 단계를 수행한다.

목표 설정: 이번 반복에서 달성할 목표 정의

위험 분석: 기술적, 관리적 위험 평가

개발 및 검증: 프로토타입이나 구현 수행

계획 갱신: 다음 반복 계획 수립

장점

위험을 조기에 발견하고 대응 가능

요구사항 불확실한 대형 프로젝트에 적합

프로토타입 기반으로 사용자 피드백 반영 가능

단점

관리가 복잡하고 문서 작업 많음

소규모 프로젝트에는 부담

2. V-모델(V-Model)

V-모델은 폭포수 모델의 확장으로
개발 단계와 검증 단계를 대칭 구조로 배치한 모델이다.

특징

단계별 검증 강조: 개발 단계마다 대응하는 테스트 단계 존재

문서화와 품질 관리 중시

순차적 진행 구조

단계

V모델에서는 왼쪽 내려가는 축이 개발 단계, 오른쪽 올라오는 축이 테스트 단계다.

요구사항 분석 → 검증 계획

시스템 설계 → 시스템 테스트 계획

아키텍처 설계 → 통합 테스트 계획

모듈 설계 → 단위 테스트 계획

구현(코딩) → 테스트 수행

장점

테스트 계획과 개발이 동시에 수립되어 품질 향상

변경이 적은 프로젝트에 적합

각 단계가 명확하게 정의되어 관리 용이

단점

요구사항 변경에 유연하지 않음

반복적 개발에는 부적합

3. 나선형 모델 vs V모델 비교
항목	나선형 모델	V모델
개발 방식	반복적, 점진적	순차적, 단계별
위험 관리	중심	상대적으로 약함
요구사항 변경	유연하게 대응 가능	변경에 취약
테스트	반복마다 수행	개발 단계에 대응하여 계획
프로젝트 유형	대형, 불확실성 높음	중소형, 요구사항 명확
4. 한 문장 요약

나선형 모델은 반복과 위험 관리를 통해 점진적 완성을 목표로 한다

V모델은 개발 단계마다 대응하는 테스트를 계획하여 품질을 보장하는 순차적 모델이다

# 보안 높은 코드 설계
1️⃣ 큰 메시지부터 잡자 (이 문장들 강력함)

블로그에서 초반에 이런 메시지 하나 던져줘 👇

보안은 마지막에 덧붙이는 기능이 아니라
처음 구조를 설계할 때 결정되는 성질이다.

또는

취약점의 대부분은 문법이 아니라
설계에서 시작된다.

2️⃣ “보안 높은 코드”를 이렇게 정의해줘

기술 나열 말고, 개념적으로 정리하면 좋아.

보안이 높은 코드란
실수해도 큰 사고로 이어지지 않도록 설계된 코드다.

👉 여기서 키워드:

공격을 완전히 막는 것 ❌

피해를 제한하고 통제하는 것 ⭕

3️⃣ 구조 설계 관점에서 중요한 보안 개념들
🔹 1. 신뢰 경계 (Trust Boundary)

외부 입력은 절대 신뢰하지 않는다

사용자, 외부 API, 파일, 네트워크 = 전부 불신

👉 설계 포인트

입력 검증 위치를 한 곳으로 집중

경계 통과 시 검증 규칙 명확화

🔹 2. 책임 분리 = 공격 표면 감소

인증 / 인가 / 비즈니스 로직 / 데이터 접근 분리

👉 효과

인증 로직이 뚫려도 데이터 계층 보호

특정 계층만 수정해도 보안 패치 가능

🔹 3. 최소 권한 원칙 (Principle of Least Privilege)

필요한 권한만 가진다

DB, 서비스, 내부 모듈 모두 포함

👉 구조적으로:

“어디서든 DB 접근 가능” ❌

“특정 계층만 접근 가능” ⭕

🔹 4. 의존성 방향은 보안 경계다

중요한 로직은 안쪽

외부와 가까운 코드는 바깥쪽

👉 Clean / Hexagonal 구조 설명할 때 딱 좋음

핵심 도메인은
프레임워크나 외부 환경에 의존하지 않는다

🔹 5. 실패를 가정한 설계 (Fail Secure)

인증 실패

권한 부족

예외 발생

👉 설계 포인트

실패 시 기본은 거부

에러 메시지는 내부 정보 숨김

4️⃣ “보안은 체크리스트가 아니라 흐름이다”로 풀어라

이 부분 넣으면 글이 단순 보안 글이 아니라 설계 글이 됨.

보안 설계 흐름 예시:

외부 입력 지점 파악

신뢰 경계 설정

중요한 자산 정의 (계정, 결제, 데이터)

접근 경로 최소화

실패 시 동작 정의

👉 코드 작성 전에 고민해야 할 질문들 중심으로 서술

5️⃣ 흔한 오해 하나 짚고 가면 설득력 UP

“보안은 라이브러리로 해결할 수 있다”

❌ NO

JWT 쓴다고 안전한 거 아님

ORM 쓴다고 SQL Injection 사라지는 거 아님

👉 구조적으로:

어디서 인증하는가

누가 인가를 책임지는가

검증 로직이 흩어져 있지 않은가

6️⃣ 구조 설계 + 생명주기 + 보안 연결하기

이 문단 넣으면 앞 글이랑 자연스럽게 이어짐 👌

소프트웨어 생명주기에서
보안 사고는 대부분 운영 단계에서 발생하지만,
그 원인은 설계 단계에 있다.

그리고:

구조가 명확 → 보안 패치 쉬움

책임 분리 → 영향 범위 제한

의존성 통제 → 취약점 전파 차단

7️⃣ 마무리 문장으로 쓰기 좋은 문장들

몇 개 던져줄게, 취향대로 골라 써도 좋아.

보안은 기술이 아니라 태도다.

보안 설계란, 최악의 상황에서도 버틸 수 있는 구조를 만드는 일이다.

안전한 코드는 ‘믿지 않는 것’에서 시작한다.

8️⃣ 전체 글에서 이 파트를 어떻게 넣으면 좋을까?

추천 위치:

구조 설계 글 중반 이후

“구조 설계가 중요한 이유” 다음 섹션

제목 예시:

구조 설계는 보안을 결정한다

보안 높은 코드는 어떻게 설계되는가

# 소프트웨어 생명주기
요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
https://chobopark.tistory.com/222

소프트웨어 생명주기(SDLC)

소프트웨어 생명주기(SDLC, Software Development Life Cycle)는
소프트웨어가 기획부터 폐기될 때까지 거치는 전체 과정을 말한다.

단순히 코드를 작성하는 것이 아니라
요구사항 수집, 설계, 구현, 테스트, 배포, 유지보수까지
체계적으로 관리하는 프로세스 프레임워크다.

1. 요구사항 분석(Requirements Analysis)

사용자가 원하는 기능과 제약 조건을 명확히 파악

“무엇을 만들어야 하는가”를 정의하는 단계

예시:

주문 관리 시스템에서는 주문 등록, 조회, 취소, 결제 기능 필요

결제는 카드, 간편 결제 등 다양한 방식 지원

결과물: 요구사항 명세서(SRS, Software Requirement Specification)

2. 설계(Design)

요구사항을 바탕으로 시스템 구조와 모듈 설계

클래스, 객체, 데이터베이스 구조, 인터페이스 등을 구체화

객체지향 설계가 활용되는 단계

예시:

Order, Payment, Customer 클래스 정의

각 클래스의 속성과 메서드, 관계 설계

UML 클래스 다이어그램, 시퀀스 다이어그램 작성

3. 구현(Implementation / Coding)

설계 내용을 바탕으로 실제 코드 작성

프로그래밍 언어와 프레임워크 선택

모듈 단위로 개발, 통합 준비

예시:

OrderService 구현

PaymentService 구현

Controller, Repository 코드 작성

4. 테스트(Testing)

개발된 소프트웨어가 요구사항을 만족하는지 검증

단위 테스트, 통합 테스트, 시스템 테스트, 사용자 수용 테스트(UAT) 포함

예시:

주문 등록 후 결제 정상 처리 확인

결제 실패 시 주문 상태 롤백 확인

5. 유지보수(Maintenance)

배포 후 운영 중 발생하는 문제 해결 및 기능 개선

버그 수정, 성능 개선, 기능 추가

소프트웨어가 계속 가치를 제공하도록 관리

예시:

정책 변경으로 할인 계산 로직 수정

신규 결제 수단 추가

서버 환경 변화 대응

6. 한 눈에 보는 SDLC

요구사항 분석 → 무엇을 만들지 결정

설계 → 어떻게 만들지 구조 설계

구현 → 코드 작성

테스트 → 기능과 품질 검증

유지보수 → 배포 후 운영과 개선

7. 한 문장 요약

SDLC는 소프트웨어를 계획, 설계, 구현, 검증, 운영까지
체계적으로 관리하여 품질과 효율성을 높이는 전체 생명주기 과정이다.

# 소프트웨어 아키텍처
소프트웨어 아키텍처란

소프트웨어 아키텍처(Software Architecture)는
시스템의 구조와 구성 요소, 구성 요소 간 관계를 정의한 청사진이다.

쉽게 말하면
“소프트웨어가 어떤 큰 틀로 설계되고 동작할 것인지”를 보여주는 설계 수준이다.

1. 아키텍처의 핵심 목적

구조 정의

모듈, 계층, 컴포넌트, 데이터 흐름 등 전체 구조 설계

예: Controller, Service, Repository 계층 구조

역할과 책임 분리

각 모듈이 어떤 기능을 담당하는지 명확히

유지보수와 확장성 향상

기술 선택 가이드

어떤 프레임워크, 데이터베이스, 메시징 시스템 등을 쓸지 결정

성능, 확장성, 안정성 등 요구사항 반영

품질 속성 보장

성능, 신뢰성, 보안, 확장성 등을 시스템 설계 단계에서 반영

2. 아키텍처 수준 예시

계층형 아키텍처(Layered Architecture)

프레젠테이션, 서비스, 데이터 접근 계층 분리

Spring MVC 구조가 대표적

클라이언트-서버 아키텍처(Client-Server)

클라이언트 요청 → 서버 처리 → 응답

마이크로서비스 아키텍처(Microservices)

여러 독립 서비스로 나누어 개발 및 배포

서비스 간 통신은 REST, 메시지 큐 등

이벤트 기반 아키텍처(Event-driven Architecture)

이벤트를 중심으로 컴포넌트 간 비동기 통신

실시간 데이터 처리 시스템에 적합

3. 아키텍처와 설계/코드의 관계
항목	아키텍처	설계	구현
범위	시스템 전체 구조	모듈/클래스 단위	실제 코드 작성
초점	구성 요소, 관계, 품질 속성	인터페이스, 클래스, 데이터 구조	동작 구현
목적	시스템 안정성과 확장성 확보	모듈 책임 명확화	기능 수행
예시	Layered Architecture, Microservices	UML 클래스 다이어그램, 시퀀스 다이어그램	Java, Python 코드

정리하면

아키텍처 = 큰 그림

설계 = 중간 설계/클래스 단위 설계

구현 = 코드

4. 한 문장 요약

소프트웨어 아키텍처는
시스템을 구성하는 요소와 관계를 정의하고 품질 속성을 반영하는 청사진으로,
잘 설계된 아키텍처는 유지보수, 확장성, 성능을 좌우한다.

# 객체지향 프로그래밍 등장배경

객체지향 프로그래밍이 등장한 배경

프로그래밍 언어의 역사를 보면 초기에는 대부분 절차지향 언어였다.
C 언어나 포트란 같은 언어가 대표적이다.

절차지향에서는 프로그램이 “무엇을 순서대로 처리할지”를 중심으로 작성된다.
함수나 루틴 단위로 코드를 쪼개고
main 함수에서 순서대로 호출하는 구조가 기본이다.

절차지향의 한계

작은 프로그램에서는 문제가 없다.
간단한 계산기, 알고리즘 문제, 스크립트 등은 절차지향으로 충분하다.

하지만 프로그램이 커지면 문제점이 드러난다.

복잡성 증가
코드가 길어지면서 함수와 데이터가 분리돼 있어
어떤 데이터가 어디서 바뀌는지 추적하기 어렵다

재사용 어려움
특정 기능을 다른 프로그램에서 쓰려면
데이터와 함수를 함께 옮겨야 하고
의존성이 많아 쉽게 재사용할 수 없다

유지보수 어려움
수정이 필요할 때 코드가 전체에 영향을 미치기 쉽다
특히 서로 얽힌 데이터와 함수가 많으면 문제는 더 심각하다

현실 세계 모델링의 어려움
사람, 물건, 주문 같은 현실 세계 개념을
함수와 절차만으로 표현하려면 복잡한 코드가 된다

객체지향의 등장

이런 문제를 해결하기 위해 **객체지향 프로그래밍(OOP)**이 등장했다.

객체지향의 핵심 아이디어는 다음과 같다.

데이터와 행동을 하나로 묶는다
사람, 주문, 결제 같은 개념을 객체로 표현
객체 안에 데이터(속성)와 행동(메서드)을 함께 둔다

캡슐화
객체 내부 데이터는 외부에서 직접 접근하지 못하고
메서드를 통해서만 다룬다
→ 데이터 변경이 통제 가능하고 오류 위험 감소

상속
공통 기능을 상위 클래스에 두고
필요한 부분만 하위 클래스에서 확장
→ 코드 재사용과 구조 강제 가능

다형성
같은 역할(인터페이스)을 수행하는 객체를
실행 시점에 바꿔 끼워 넣을 수 있음
→ 변경에 유연하고 테스트가 쉬움

즉 객체지향은

“프로그램을 현실 세계와 비슷하게 모델링하고
복잡성을 관리하며
재사용성과 유지보수를 높이는 방법”으로 등장한 것이다.

실생활 예시

주문 처리 프로그램을 예로 들어보자.

절차지향 방식:

main 함수에서 주문 입력, 결제, 배송, 로그를 순서대로 처리

각 단계마다 여러 함수 호출

데이터가 함수 밖에서 바뀔 수 있어 추적 어려움

객체지향 방식:

주문(Order) 객체, 결제(Payment) 객체, 배송(Delivery) 객체로 나눔

각 객체가 자기 데이터와 행동을 담당

main 함수에서는 객체를 조합하고 호출만 함

요구사항 변경 시 특정 객체만 수정하면 됨

한 문장 요약

객체지향 프로그래밍은
프로그램 복잡성을 관리하고 재사용과 유지보수를 쉽게 하기 위해
데이터와 행동을 하나의 객체로 묶고 현실 세계를 모델링한 프로그래밍 패러다임이다.

절차지향 vs 객체지향 비교표
항목	절차지향	객체지향
중심	함수(프로세스, 로직)	객체(데이터 + 행동)
데이터 처리	함수와 데이터 분리	데이터와 행동을 객체 안에 묶음
코드 재사용	함수 단위 재사용	상속과 다형성으로 재사용
유지보수	코드가 길어지고 의존 많으면 어려움	객체 단위로 책임 분리, 수정 영향 최소화
현실 세계 모델링	어려움, 데이터와 행동이 분리	자연스럽게 모델링 가능
실행 흐름	순차적, main 함수 중심	객체 간 메시지 전달과 상호작용 중심
확장성	어려움, 함수 수정 필요	새로운 객체 추가로 확장 가능
테스트	전체 함수 호출 필요, 독립적 테스트 어려움	객체 단위 테스트 용이
예시	계산기, 단순 스크립트	주문 처리 시스템, 결제 시스템, 서버 애플리케이션
추가 설명

절차지향은 **“무엇을 순서대로 처리할 것인가”**에 집중

객체지향은 **“누가 무엇을 담당할 것인가”**에 집중

복잡한 프로그램일수록 객체지향이 관리와 확장에 유리하다

# 소프트웨어 개발 방법론과 객체지향 설계 모델링의 차이

소프트웨어 개발 방법론과 객체지향 설계 모델링은 다른 개념일까

개발을 하다 보면 흔히 듣는 용어가 있다.

애자일, 폭포수, 나선형, 프로토타입 같은 개발 방법론과
객체지향 설계, UML, 클래스 다이어그램 같은 설계 모델링이다.

겉으로 보면 둘 다 설계와 관련된 것 같지만
엄밀히 말하면 역할과 목적이 완전히 다르다.

1. 소프트웨어 개발 방법론

개발 방법론은 프로젝트를 어떻게 진행할지를 정의한다.

주요 예시는 다음과 같다.

폭포수(Waterfall)

단계별 순차 진행: 요구사항 → 설계 → 구현 → 테스트 → 배포

각 단계가 끝나야 다음 단계로 넘어감

계획 중심, 변경이 어려움

애자일(Agile)

반복적, 점진적 개발

스프린트 단위로 기능을 구현하고 점검

요구사항 변경에 유연하게 대응 가능

나선형(Spiral)

위험 관리 중심

반복하면서 점차 완성도 높임

큰 프로젝트에 적합

프로토타입(Prototype)

최소 기능으로 빠르게 시제품 제작

사용자 피드백을 받아 개선

요구사항 불확실한 경우 유용

정리하면 개발 방법론은
**“팀이 소프트웨어를 언제, 어떻게 만들 것인가”**를 정의하는 프레임워크다.

2. 객체지향 설계 모델링

반면 객체지향 설계 모델링은 소프트웨어 내부 구조를 어떻게 설계할 것인가에 초점을 둔다.

주요 내용은 다음과 같다.

클래스와 객체 정의

속성과 메서드 설계

상속과 다형성 적용

UML 클래스 다이어그램, 시퀀스 다이어그램 작성

즉 **“코드와 시스템의 구조를 어떻게 나눌 것인가”**를 구체화하는 과정이다.

3. 차이와 관계
항목	개발 방법론	객체지향 설계 모델링
목적	프로젝트 진행 방식 정의	소프트웨어 구조 설계
범위	전체 프로젝트, 팀, 일정	클래스, 객체, 모듈 단위
시점	프로젝트 초기 계획부터 배포까지	설계 단계 및 구현 전후
변경 대응	방법론에 따라 유연성 다름	구조를 어떻게 확장/변경할지 계획
예시	애자일, 폭포수, 나선형, 프로토타입	UML, 클래스 다이어그램, 상속/인터페이스 설계

쉽게 말하면

개발 방법론은 소프트웨어를 만드는 ‘길’을 안내한다

객체지향 설계 모델링은 그 길 위에서 ‘무엇을 만들지’와 ‘어떻게 만들지’를 정의한다

둘은 상호 보완적이다.
예를 들어 애자일을 적용한다고 해도
객체지향 설계 원칙 없이 코드를 만들면
유지보수와 확장이 어려운 코드가 나온다.

반대로 설계만 잘 해도
프로젝트 관리가 엉망이면 일정과 품질을 지키기 어렵다.

4. 한 문장 요약

개발 방법론은 **“소프트웨어를 언제, 어떻게 만들 것인가”**를 다루고
객체지향 설계 모델링은 **“소프트웨어 내부 구조를 어떻게 구성할 것인가”**를 다룬다.

둘은 다른 개념이지만
좋은 소프트웨어를 만들기 위해서는 함께 고려해야 하는 상호 보완적 요소다.

# 객체 생성과 인스턴스

단순 프로그램에서 클래스로 객체를 만들어 실행하는 것과
main 함수에서 바로 실행하는 것의 차이

자바로 간단한 프로그램을 만들다 보면 이런 고민을 하게 된다.
기능이 하나뿐인데 굳이 클래스를 만들고 객체를 생성해야 할까
main 함수에서 그냥 실행하면 더 간단하지 않을까

결론부터 말하면 둘 다 가능하다.
다만 두 방식은 목적이 다르다.

main 함수에서 바로 실행하는 방식

가장 단순한 형태는 모든 로직을 main 함수에 작성하는 것이다.

public class Main {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        System.out.println(a + b);
    }
}


이 방식의 특징은 명확하다.

코드가 단순하다
빠르게 결과를 확인할 수 있다
한 번 실행하고 끝나는 프로그램에 적합하다

그래서 알고리즘 문제나 간단한 테스트 코드에서는 이 방식이 가장 효율적이다.

하지만 이 구조는 프로그램이 조금만 커져도 한계가 드러난다.

객체를 만들어 실행하는 방식

같은 기능을 객체로 분리해보면 구조가 이렇게 바뀐다.

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        System.out.println(calculator.add(10, 20));
    }
}


이 방식은 처음엔 오히려 번거롭게 느껴질 수 있다.
하지만 역할이 분리되면서 얻는 이점이 생긴다.

두 방식의 가장 큰 차이

차이는 코드 길이가 아니라 책임에 있다.

main 함수에 로직을 직접 쓰는 방식은
실행과 계산이 한 곳에 섞인다.

객체를 만들어 사용하는 방식은
실행은 main이 담당하고
일은 객체가 담당한다.

이 분리가 객체지향의 출발점이다.

객체로 분리하면 무엇이 달라질까

첫째 책임이 명확해진다.
Calculator는 계산만 담당하고
main은 프로그램 시작과 실행만 담당한다.

둘째 재사용이 가능해진다.
Calculator는 다른 프로그램에서도 그대로 사용할 수 있다.

셋째 테스트가 쉬워진다.
main을 실행하지 않고도 Calculator만 단독으로 테스트할 수 있다.

Calculator calculator = new Calculator();
assert calculator.add(1, 2) == 3;


넷째 변경에 강해진다.
계산 방식이 바뀌어도 main 코드는 수정할 필요가 없다.

main 함수에 로직을 두면 생기는 문제

프로그램이 커질수록 main 함수는 이런 모습이 된다.

public static void main(String[] args) {
    // 입력 처리
    // 계산 로직
    // 조건 분기
    // 출력
}


모든 책임이 한 곳에 몰린다.
수정할 때마다 전체 흐름을 다시 이해해야 한다.

이 구조는 단순한 스크립트에는 괜찮지만
지속적으로 수정되는 프로그램에는 맞지 않는다.

객체를 쓰는 진짜 이유

객체를 쓰는 이유는 객체 생성 자체가 목적이 아니다.
변경과 확장을 대비하기 위함이다.

처음에는 단순 계산이지만
나중에는 저장 기능이 추가되고
검증 로직이 들어가고
다른 계산 방식이 필요해질 수 있다.

이때 객체로 분리된 구조는 자연스럽게 확장된다.

그럼 언제 main 함수에서 바로 실행해도 될까

다음 조건이라면 main에 직접 작성해도 충분하다.

한 번 실행하고 끝나는 코드
확장 가능성이 없는 실험용 코드
알고리즘 문제 풀이
학습용 예제

반대로 이런 경우라면 객체로 분리하는 게 낫다.

기능이 늘어날 가능성이 있는 경우
여러 곳에서 재사용될 수 있는 로직
테스트가 필요한 코드
역할을 명확히 나누고 싶은 경우

한 문장 정리

main 함수에서 바로 실행하는 코드는
지금 당장 실행하기 위한 코드이고

객체를 만들어 실행하는 코드는
앞으로 변경될 것을 전제로 한 코드다.