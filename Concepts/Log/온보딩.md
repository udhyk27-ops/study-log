웹뷰 앱에 애니메이션 SVG파일을 온보딩 화면으로 구현

플러터에서는 애니메이션이 들어간 SVG파일을 띄울수없었음 (정적svg)만 가능

Lottie또는 Rive로 변환해야하는데 다시 만들어야 하는 상황 발생 (디자인팀)

기존엔 온보딩 화면이 앱화면이였고 그 후에 웹뷰로 넘어갔으나 온보딩도 웹뷰로 구현해야겠다 생각

SVG 소스를 HTML안에 넣고 웹뷰로 띄움

https://www.appicon.co/
에서 해상도별 mipmap이미지를 생성 가능

나는 flutter_launcher_icons 라이브러리 사용했음

android/app/src/main/res/values-v31 안의 styles.xml에
        <item name="android:windowSplashScreenAnimatedIcon">@android:color/transparent</item>
        <item name="android:windowSplashScreenBackground">#FFFFFF</item>
를 추가했더니 정상적으로 스플래시 화면이 바뀌었다.

기존 Splash화면을 사용하다가 애니메이션을 넣느라 Splash화면을 따로 만들어서 로드하므로 main.dart를 변경해줘야 했다.

기존엔 main함수에서 preferences, firebase, api등의 data 로드를 전부 완료한 후에 화면을 넘겨줬으나 
나는 Splash화면을 커스텀으로 만들었기 때문에main.dart에서 화면을 넘겨주는 작업이 짧을수록 사용자가 체감하기에 내가 만든 커스텀 스플래시 화면이 진짜 스플래시 화면이라고 생각할 것이다.

그래서 data를 가져오는 작업은 내 커스텀 스플래시 파일에 옮기고 main.dart에서는 커스텀 스플래시로 단순 화면이동만 하였다.

내 애니메이션이 3초정도 되기 때문에 최소 3초 보여주되 데이터의 로드가 끝나지않으면 화면을 넘기지않았다.
AnimatedSplash.dart

  Future<void> _initializeData() async {
    try {
      await Firebase.initializeApp();
	// Firebase가 안전하게 초기화되어야 사용할수있는 메서드들이기 때문에 Firebase먼저 초기화 시킨 후 실행
	
      final results = await Future.wait([
        SharedPreferences.getInstance(),
        Api().getRemoteConfig(), // 이제 Firebase가 준비되어 안전하게 로드됨
        Future.delayed(const Duration(seconds: 3)),
      ]);

      // 로드 확인 로그
      print("데이터 확인: ${Api.onBoardText['first_page']}");

      // 결과물 꺼내기 (이제 index가 당겨졌으니 주의!)
      final SharedPreferences prefs = results[0] as SharedPreferences;
      bool showOnboarding = prefs.getBool('showOnboarding') ?? false;

      if (!mounted) return;

      // 이동 로직...
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          // builder: (context) => showOnboarding ? const HomeScreen() : const OnboardingScreen(),
          builder: (context) => const OnboardingScreen(),
        ),
      );
    } catch (e) {
      debugPrint("초기화 에러: $e");
    }
  }


기존 Api.dart에서
import 'dart:convert';
import 'dart:io';
import 'package:firebase_remote_config/firebase_remote_config.dart';

class Api {
  static String appVersion = "";
  static String storeUrl = "";
  static String webViewUrl = "";
  static Map<String, Map<String, dynamic>> onBoardText = {};

  Future<void> getRemoteConfig() async {

    try {
      final FirebaseRemoteConfig rc = FirebaseRemoteConfig.instance;
      await rc.setConfigSettings(RemoteConfigSettings(
        fetchTimeout: const Duration(seconds: 10),
        minimumFetchInterval: Duration.zero,
      ));
      await rc.fetchAndActivate();

      if (Platform.isAndroid) {
        appVersion = rc.getString('appVersion_AOS');
        storeUrl = rc.getString('storeUrl_AOS');
      } else {
        appVersion = rc.getString('appVersion_IOS');
        storeUrl = rc.getString('storeUrl_IOS');
      }

      // Web View Url
      webViewUrl = rc.getString('webViewUrl');

      // On Board Text
      String onBoardTextString = rc.getString('onBoardText');
      onBoardText = Map<String, Map<String, dynamic>>.from(jsonDecode(onBoardTextString));

    } catch (e) {
      print('REMOTE CONFIG ERROR: $e');
    }

  }
}

기존에는 static으로 변수를 선언하여 Api에서 가져온 데이터들을 저장하고 사용하였다.
다른 파일에서 호출할 때 : Api.onBoardText

Api.dart를 싱글톤으로 만들어서 인스턴스 변수에 데이터를 저장하고 어디서든 같은 객체를 바라보게 만들었다.
  static final Api _instance = Api._internal();
  factory Api() => _instance;
  Api._internal();
  
  다른 파일에서 호출 방법
  final api = Api();
  api.onBoardText
  
  -> Dart 2.0버전부터는 객체를 만들 때 new 키워드를 생략하는 것이 표준 방식이라고 한다.
  
  
  
  
비교 항목	static 변수 방식	싱글톤(인스턴스) 방식
객체지향(OOP)	절차지향적 (전역 변수 묶음)	객체지향적 (상태를 가진 객체)
확장성	인터페이스 구현이나 상속이 불가능	다른 클래스를 상속받거나 확장 가능
의존성 주입(DI)	불가능 (테스트가 매우 어려움)	가능 (GetIt 등의 라이브러리와 궁합 최고)
생명주기 관리	앱 시작부터 끝까지 메모리 점유	필요한 시점에 초기화(Lazy init) 가능

