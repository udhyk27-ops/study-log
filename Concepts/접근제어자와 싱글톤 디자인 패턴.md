# 접근제어자 private와 protected 선택 기준

자바에서는 클래스 내부와 외부에서 변수, 메서드, 클래스에 접근할 수 있는 범위를 제어하기 위해 접근제어자를 사용한다.

주요 접근제어자는 다음과 같다.

접근제어자	접근 범위
private	같은 클래스 내부만 접근 가능
protected	같은 패키지 + 하위 클래스 접근 가능
default(패키지)	같은 패키지 내부만 접근 가능
public	어디서나 접근 가능
1. 필드(멤버 변수)는 보통 private

클래스 내부에서만 직접 접근하도록 제한

외부에서 접근할 때는 getter/setter를 사용

캡슐화(encapsulation) 원칙을 지키는 기본 방법

public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


이렇게 하면 내부 구현을 바꿔도 외부 코드에 영향을 최소화할 수 있다.

2. protected는 상속을 고려할 때 사용

하위 클래스에서 직접 접근해야 하는 변수나 메서드에 사용

패키지가 달라도 상속 관계라면 접근 가능

public class BaseOrder {
    protected int orderId;

    protected void printOrder() {
        System.out.println("Order: " + orderId);
    }
}

public class SpecialOrder extends BaseOrder {
    public void applyDiscount() {
        orderId += 100; // protected이므로 하위 클래스에서 직접 접근 가능
        printOrder();
    }
}


주의: protected를 남용하면 캡슐화가 깨지고 클래스 간 결합도가 높아질 수 있음

3. 선택 기준 정리
상황	추천 접근제어자	이유
외부에서 절대 접근하면 안 되는 필드/메서드	private	내부 구현을 보호하고 캡슐화 유지
하위 클래스에서 재사용/확장 필요	protected	상속 시 직접 접근 가능, 코드 재사용 용이
외부와 자유롭게 접근 가능해야 하는 API	public	공개 인터페이스 역할
같은 패키지 안에서만 사용	default	제한적 접근, 패키지 경계 관리
4. 실무 관습

필드는 거의 항상 private

getter/setter로 외부 접근 통제

메서드 중 상속해서 재사용할 필요 있는 경우 protected

클래스 자체를 상속받아 확장할 필요가 없으면 final + private

요약: “필드는 private, 메서드는 필요에 따라 protected”가 기본 원칙.
필드를 protected로 두는 경우는 하위 클래스에서 내부 상태를 직접 제어해야 할 때만 사용.
남용하면 클래스 간 결합도가 올라가 유지보수 어렵다.

# 싱글톤(Singleton) 패턴은
애플리케이션 전체에서 인스턴스를 단 하나만 생성하도록 보장하는 디자인 패턴이다.

객체를 여러 번 생성하면 문제가 되는 상황에서,
“이 클래스의 인스턴스는 무조건 하나만 존재해야 한다”는 제약을 걸고 싶을 때 사용한다.

싱글톤의 사용
싱글톤은 보통 아래와 같은 경우에 사용된다.

대표적으로 여러 객체가 동시에 접근해야 하지만,
인스턴스는 하나만 존재해야 의미가 있는 경우에 적합하다.

예를 들어,
애플리케이션 전반에서 공통으로 사용하는 설정 객체
데이터베이스 커넥션이나 커넥션 풀 관리 객체
로그를 중앙에서 관리하는 로거(Logger)

이런 객체들은 여러 개가 생성되면
오히려 문제가 되거나 리소스 낭비로 이어질 수 있다.

따라서 객체 생성 비용이 크거나, 상태를 일관되게 유지해야 하는 경우
단 하나의 인스턴스를 보장하기 위해 싱글톤 패턴을 사용한다.


싱글톤이 되기 위한 3가지 조건

1. 생성자가 private
→ 외부에서 new로 객체 생성 불가

2. 자기 자신 타입의 static 인스턴스를 가짐
→ 클래스당 하나만 유지

3. static 메서드로 인스턴스를 제공
→ getInstance() 같은 형태

싱글톤 구현 예시
public class Singleton {

    // 1. 자기 자신 타입의 static 변수
    private static Singleton instance;

    // 2. 생성자를 private으로 막음
    private Singleton() {}

    // 3. 인스턴스를 반환하는 static 메서드
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}


싱글톤 클래스에서는 인스턴스를 static 변수로 보관한다.
static으로 선언된 변수는 클래스당 하나만 존재하기 때문에, 어떤 위치에서 접근하더라도 항상 동일한 객체를 사용하게 된다.

또한 생성자를 private으로 선언해
외부에서 new Singleton()과 같은 방식으로 객체를 직접 생성하는 것을 막는다.

이를 통해 객체 생성에 대한 책임을 클래스 내부로 한정하고, 인스턴스가 무분별하게 생성되는 상황을 방지한다.

마지막으로 static 메서드를 통해 인스턴스를 제공한다.
이 메서드는 객체 생성 없이 호출할 수 있으며, 최초로 호출되는 시점에만 인스턴스를 생성하도록 구현할 수 있다.

생성자가 public이라면 싱글톤의 의미가 깨지게 된다.

Singleton s1 = new Singleton();
Singleton s2 = new Singleton();


싱글톤 동작 검증
public class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2); // true
    }
}

싱글톤이라면 두 객체는 같은 참조를 가져야 하므로 true가 출력된다.



싱글톤의 문제점은 멀티 스레드 환경에서 안전하지 않다는 것이다.
if (instance == null) {
    instance = new Singleton();
}


두 개의 스레드가 동시에 접근할 경우, 인스턴스가 두 번 생성될 가능성이 있다.
즉, 멀티 스레드 환경에서는 단순한 클래식 싱글톤 구현이 깨질 수 있다.

이러한 문제로 인해 프로그래밍에서는 단순한 클래식 싱글톤 대신
스레드 안정성을 보장할 수 있는 다른 싱글톤 구현 방식들이 함께 사용된다.

Spring에서의 싱글톤
@Service
public class UserService {}

@Autowired
UserService userService;


Spring 환경에서는 new나 getInstance() 같은 코드를 개발자가 직접 작성하지 않는다.

대신 Spring 컨테이너가 객체를 생성하고 관리하며, 필요한 시점에 해당 객체를 주입해 준다.

Spring에서 말하는 싱글톤은 일반적인 싱글톤 패턴과는 조금 다른 개념이다.
이는 클래스 자체의 제약이 아니라 컨테이너 스코프(scope) 에 대한 개념이다.

Spring 컨테이너는 컨테이너 내부에서 생성되는 객체의 개수를 관리하며,
기본적으로 하나의 인스턴스만 생성해 공유한다.

이 인스턴스는 애플리케이션 시작 시 생성되어 컨테이너가 살아 있는 동안 유지된다.

이 구조에서 중요한 점은 개발자가 객체에 상태를 두지 않도록 설계한다는 것이다.
이를 통해 여러 스레드가 동시에 접근하더라도 안전하게 객체를 사용할 수 있다.

클래식 싱글톤이 코드로 인스턴스를 하나로 제한하는 방식이라면,
Spring의 싱글톤은 컨테이너가 객체의 생명주기를 관리하는 방식이다.


참고
https://ittrue.tistory.com/563