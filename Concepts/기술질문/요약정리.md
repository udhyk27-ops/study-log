# JAVA 자료형
+ 정수형
	- byte - 1byte - 0
	- short - 22byte - 0
	- int - 4byte - 0
	- long - 8byte - 0L
+ 문자형
	- char - 2byte
+ 실수형
	- float - 4byte - 0.0f
	- double - 8byte - 0.0d
+ 논리형
	- boolean - 1byte - false

# 참조 자료형
+ String : 문자열 저장 클래스
+ ArrayList : 동적 배열 클래스
+ HashMap : 키와 값 클래스
+ HashSet : 고유한 요소 클래스
+ Linked List : 연결 리스트 클래스
+ Queue : 큐 인터페이스
+ Stack : 스택 클래스

# Collection (순서나 집합적인 저장공간) 종류
+ List : 순서가 있는 데이터의 집합, 데이터의 중복 허용
	- LinkedList
	- Stack
	- Vector
	- ArrayList
+ Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음
	- HashSet
	- TreeSet

# 변수란
+ 데이터를 저장할 수 있는 메모리 상의 공간

# 메소드
+ 클래스 내부에서 정의된 객체의 함수

# 클래스
+ 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 틀

# REST 방식
+ Controller에서 문자로 값을 되돌려 줌

# 스프링 사용하면 장점
+ 객체 간 의존성을 주입하여 코드의 재사용성과 생산성이 높아짐

# JSP란

# JSTL 이란
+ JSP에서 자주 사용되는 기능들을 태그 형태로 제공하는 라이브러리

# 자바 메모리 영역
+ 메소드, 힙, 스택으로 나뉜다. 메소드 영역에는 클래스 파일, 메소드 정보, static 변수등이 저장됨
+ 힙 영역에는 객체와 배열이 생성되는 영역으로 가비지 컬렉션의 대상
+ 스택 영역은 메소드 호출과 관련된 지역변수, 매개변수, 리턴 값 등을 저장

# MVC 패턴
+ 모델, 뷰, 컨트롤러로 구분됨
+ 모델은 데이터와 비즈니스 로직을 담당
+ 뷰는 사용자에게 데이터를 보여주는 역할
+ 컨트롤러는 요청을 받아 모델을 업데이트하고 적절한 뷰를 선택하여 사용자에게 응답

# GET / POST
+ GET은 URL을 통해 데이터 전송하며 정보를 요청할 때 사용됨 - 대용량 데이터 보내기 어려움
+ POST 는 데이터를 HTTP 요청 본문에 담아 전송하며 데이터를 서버로 제출하거나 업데이트할 때 사용됨 - 대용량 데이터 가능

# 서블릿
+ 웹 서버에서 실행되면서 HTTP 요청을 받아 처리하고 응답을 만들어 주는 기술

# 톰캣이란
+ 서블릿 컨테이너와 웹 서버 기능 제공

# WAS 란
+ 서블릿 컨테이너를 포함하며 서블릿을 실행하고 JSP를 해석하여 클라이언트 요청에 응답
+ 데이터베이스 연결, 트랜잭션 관리, 보안, 네트워크 통신 등의 기능 제공

# WEB 서버와 WAS의 차이
+ WEB 서버는 정적인 콘텐츠 처리 ( HTML, CSS, 이미지) - Nginx, Apache Http Server
+ WAS는 프로그램(로직)을 실행해서 결과를 만들어 주는 서버
+ WAS 는 동적 컨텐츠 처리 (로그인 처리, API 응답 생성, 서버 로직 실행, DB 조회) - Tomcat, Spring Boot 내장 서버 등

# 객체지향이란
+ 데이터를 객체라는 단위로 나누고, 객체들간의 상호작용을 통해 프로그램을 구성하는 방식

# SOLID
+ S (Single Responsibility Principle) 단일 책임 원칙
	- 모든 클래스는 하나의 책임만 가져야 하고 클래스를 변경해야 하는 이유는 오직 하나여야 한다.
+ O (Open/Closed Principle) 개방-폐쇄 원칙
	- 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 기존 코드를 변경하지 않고 기능을 추가할 수 있어야 한다.
+ L (Liskov Substitution Priciple) 리스코프 치환 원칙
	- 부모 클래스는 자식 클래스로 대체 가능해야 한다.
+ I (Interface Segregation Principle) 인터페이스 분리 원칙
	- 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공해야 한다.
+ D (Dependency Inversion Principle) 의존 역전 원칙
	- 상위 모듈은 하위 모듈에 의존해서는 안 되며, 추상화에 의존해야 한다. 구체적인 클래스가 아닌 인터페이스나 추상 클래스에 의존해야 한다.

# API (Application Programming Interface)
+ 소프트웨어 애플리케이션 간의 상호작용을 위한 프로토콜의 집합

# 트랜잭션이란
+ 하나의 논리적인 작업 단위

# ACID
+ 원자성 (Atomicity)
+ 일관성 (Consistency)
+ 격리성 (Isolation)
+ 지속성 (Durability)

# 쿼리 실행 순서
1. FROM
2. JOIN
3. WHERE
4. GROUP BY
5. HAVING
6. SELECT
7. ORDER BY

# 가비지 컬렉션이란
+ 사용되지 않거나 더 이상 참조되지 않는 메모리 블록을 회수하는 것
+ 메모리 누수 방지, 메모리 관리 자동화

# CORS (Cross - Origin Resource Sharing)
+ 웹 브라우저에서 서로 다른 도메인 간에 리소스를 공유할 수 있도록 허용하는 메커니즘

# HTTP 상태코드
+ 1xx (정보) - 클라이언트가 요청을 계속해야 함을 나타냄
+ 2xx (성공) - 클라이언트의 요청이 성공적으로 처리되었다.
+ 3xx (리다이렉션) - URL 관련 문제
+ 4xx (클라이언트 오류) - 요청한 리소스를 찾을 수 없음
+ 5xx (서버 오류) - 서버가 요청을 처리할 수 없음

# HTTP 메소드 종류
+ GET, POST, PUT, DELETE, PATCH ...

# 참조자료형 특징
+ String, 배열, 클래스, 인터페이스
+ 실제 데이터가 저장된 힙 메모리 주소를 참조

# call by value
+ 메소드에 전달된 변수의 값이나 참조 주소의 복사본이 메소드 파라미터로 전달됨

# 디자인 패턴 종류
+ 생성 패턴
	- 싱글톤 패턴 : 하나의 클래스 인스턴스를 전역에서 접근 가능하게 하고 해당 인스턴스가 한 번만 생성되도록 보장하는 패턴
	- 추상 팩토리 패턴
	- 빌더 패턴 : 복잡한 객체를 단계별로 생성하는 방법을 정의
+ 구조 패턴
	- 어댑터 패턴
	- 데코레이터 패턴
	- 프록시 패턴 : 다른 객체에 대한 대리자 (Proxy)를 제공하여 접근제어, 지연로딩 등을 구현하는 패턴
+ 행위 패턴
	- 전략 패턴
	- 옵저버 패턴

# 정규화, 비정규화
+ 정규화 : 테이블 구조를 최적화하여 중복을 줄이고 데이터 무결성을 보장하기 위한 과정
+ 비정규화 : 의도적으로 중복을 허용하여 성능 최적화 (JOIN 수를 줄이고 SELECT 속도 향상)
	- 제 1정규화 : 테이블의 컬럼이 원자값만 가지도록 분해
	- 제 2정규화 : 1정규화를 만족하고, 기본키가 복합키일 때 부분 함수 종속을 제거
	- 제 3정규화 : 2정규화를 만족하고, 기본키 이외의 일반 컬럼 간에 이행적 함수 종속을 제거 (A → B, B → C일 때 A → C인 관계를 제거)
	- BCNF : 3정규화를 만족하고, 모든 결정자가 후보키가 되도록 하여 후보키가 아닌 결정자를 제거
	- 제 4정규화 : BCNF를 만족하고, 다치 종속을 제거
	- 제 5정규화 : 4정규화를 만족하고, 조인 종속을 제거
	
# 오버라이딩과 오버로딩의 차이
+ 오버라이딩 : 상속 관계에 있는 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것
	- 자식 클래스는 부모 클래스의 메서드와 동일한 메서드명과 반환 타입을 가져야 함
+ 오버로딩 : 같은 클래스 내에서 동일한 이름을 가진 메서드를 여러 개 정의하는 것
	- 각 메서드는 변수의 타입, 개수, 순서를 다르게 가져야 함

# JSP에서 세션을 관리하는 방법
+ HttpSession 객체를 통해 세션을 생성하거나 기존 세션을 얻음
+ request 객체를 통해 접근 가능

# OOP 특징
+ 캡슐화 (Encapsulation): 데이터와 메소드를 하나로 묶고, 외부 접근을 제한하여 데이터 충돌 방지
+ 상속 (Inheritance) : 상위 클래스의 기능을 하위 클래스가 물려받아 코드를 재사용하고 확장
+ 다형성 ( Polymorphism) : 같은 이름의 메소드가 상황에 따라 다르게 동작하여 인터페이스를 통한 유연한 설계를 가능하게 함
+ 추상화 (Abstraction) : 복잡한 내부 구현을 숨기고 필요한 공통적인 특성만 추출하여 단순화

# 접근제어자
+ public : 모든 클래스에서 접근 가능
+ protected : 동일 패키지 또는 서브클래스에서 접근 가능
+ default : 접근제어자를 명시하지 않은 경우, 동일 패키지에서 접근 가능
+ private : 해당 클래스 내에서만 접근 가능

# 배열과 리스트의 차이점
+ 배열
	- 고정된 크기
	- 기본 타입과 객체 타입 저장 가능
	- 선언과 동시에 크기 지정해야 함
+ 리스트
	- 크기가 동적으로 변함
	- 객체 타입만 저장 가능
	- 다양한 메소드 제공

# RESTful 이란
+ HTTP 메소드를 사용하여 자원 조작
+ URL을 통해 자원을 식별

# Spring 동작방식
+ 클라이언트가 요청
+ 디스패처 서블릿이 요청 받음
+ 디스패처 서블릿이 핸들러 매핑을 통해 컨트롤러를 찾음
+ 컨트롤러(핸들러 어댑터)가 요청을 처리 후 모델 데이터를 생성하여 뷰 리졸버에 전달
+ 뷰 리졸버가 적절한 뷰를 선택하여 렌더링하고, 클라이언트에 응답을 반환

# 스프링 프레임워크 특징
+ POJO 기반 개발 : 자바 객체를 사용한 개발
+ 의존성 주입 : 객체 간의 의존성을 관리
+ AOP (Aspect - Oriented Programming) : 횡단 관심사를 모듈화
+ 모듈성 : 다양한 모듈을 제공하여 유연한 애플리케이션 개발
+ 트랜잭션 관리 : 선언적 트랜잭션 관리 지원

# JOIN 종류
+ INNER JOIN
+ OUTER JOIN
+ CROSS JOIN
+ SELF JOIN

# JVM 역할
+ JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주고 가비지컬렉션을 통해 메모리 관리

# try - with - resources
+ try - catch - finally 의 문제점을 보완하기 위해 나온 개념
+ try() 안에 객체를 전달하면, try 블록이 끝난 후 자동으로 자원을 해제하는 기능
+ finally 또는 catch 구문에 종료 처리를 하지 않아도 됨

# 싱글톤 패턴
+ 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴

# 가비지 컬렉션
+ 시스템에서 동적으로 할당됐떤 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법

# 클래스와 객체
+ 클래스는 객체를 만들어내기 위한 설계도 혹은 틀
+ 객체는 고유 이름과 필드, 메소드를 갖는 것
+ 인스턴스는 객체에 메모리가 할당되어 실제로 활용되는 실체

# Wrapper Class, Boxing과 UnBoxing
+ Wrapper Class : 기본 자료형에 대한 객체 표현
+ Wrapper Class -> 기본자료형으로 변환하는 것 : UnBoxing

# Synchronized 란
+ 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념
+ 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장함
+ Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, 남발하게 되면 프로그램의 성능저하를 일으킬 수 있음

# new String() 과 리터럴("")의 차이점
+ new String() 은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장됨
+ 리터럴은 Heap 안에 있는 String Constant Pool 영역에 저장됨 (재사용됨)

# String, StringBuffer, StringBuilder의 차이점
+ String은 불변의 속성을 가지며, StiringBuffer와 StringBuilder는 가변의 속성을 가짐
+ StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용
+ StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용

# 접근 제한자 (Access Modifier)에 대해 설명
+ 변수 또는 메소드의 접근 범위를 설정해주기 위해 사용하는 JAVA의 예약어
+ public - 같은 프로젝트 내 어디서든 사용 가능
+ protected - 해당 패키지 내, 다른 패키지에서 상속받아 자식 클래스에서 접근 가능
+ default - 해당 패키지 내에서만 접근 가능
+ private - 해당 클래스에서만 접근 가능

# 클래스 멤버 변수 초기화 순서
+ static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 됨
+ 필드 변수 선언부 : 객체가 생성될 때 생성자 block보다 앞서 초기화 됨
+ 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking (thread - safe 영역)

# static 설명
+ static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용 가능
+ 즉, 인스턴스 (객체) 생성 없이 바로 사용 가능하다.
+ 모든 객체가 메모리를 공유하고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재함

# Inner Class (내부 클래스) 의 장점
+ 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근 가능
+ 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고 코드의 복잡성을 낮출 수 있다.
+ 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.

# 리플렉션이란
+ 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

# Error와 Exception의 차이
+ Error는 실행 중 일어날 수 있는 치명적 오류, 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속함
+ Exception은 Error보다 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있음

# Set, Map 타입이 객체를 받을 때 중복 검사 하는 방법
+ hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단
+ 해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교함
+ 이 두 개가 모두 맞으면 중복 객체

# Vector 와 List의 차이
+ 벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가짐
+ 벡터는 랜덤부분 접근이 가능하지만 리스트는 더블 링크드 리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않음
+ 벡터는 리스트와 달리 항상 동기화됨, 멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경일 때도 동기화를 하기 때문에 List보다 성능이 떨어짐

# 제네릭 설명
+ 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미
+ 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 ㅜㅁㄴ제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있음

# finalize 란
+ Object 클래스에 정의되어있는 메소드
+ GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드

# 직렬화 (Serialize) 설명
+ 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 하는 바이트 형태로 데이터 변환하는 기술
+ 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 역직렬화라고 함
+ JVM의 메모리에 상주되어있는 객체 데이터를 바이트 형태로 변환하는 기술

# SerialVersionUID를 선언해야 하는 이유
+ JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됨
+ 그래서 직렬화할때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용함
+ 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있음

# 스프링 프레임워크
+ 경량 컨테이너로서 자바 객체를 직접 관리
+ 제어의 역전(Ioc)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
	 - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출함
+ 의존성 주입(DI, Dependency Injection) 을 지원
	- 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
+ 관점 지향 프로그래밍 (AOP, Aspect-Oriented Programming)을 지원
	- 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

# RequestBody, RequestParam, ModelAttribute의 차이점
+ RequestBody는 클라이언트가 전송하는 JSON형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할
+ RequestParam은 1개의 HTTP 요청 파라미터를 받기 위해 사용
	- RequestParam은 필수 여부가 true이기 때문에 기본적으로 해당 파라미터가 전송되어야 함
	- 전송되지 않으면 400에러 유발할 수 있고 필요한 변수가 아니라면 required의 값을 false로 설정해야 함
+ ModelAttribute는 HTTP Body 내용과 HTTP 파라미터의 값들을 생성자, Getter, Setter를 통해 주입하기 위해서 사용
	- 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter, Setter가 없으면 변수들이 저장되지 않는다.

# Spring Boot와 Spring Framework 의 차이점
+ Auto Configuration - Spring은 프로젝트 쵝에 다양한 환경설정을 해야 하지만, Boot는 많은 부분을 자동화함
+ spring boot starter dependency만 추가해주면 설정이 끝나고 내장된 톰캣을 제공해 서버를 바로 실행 가능

# Spring MVC 처리 순서
1. 클라이언트는 URL을 통해 요청을 전송한다.
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청에 해당하는 컨트롤러를 찾는다.
3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
5. 컨트롤러는 로직을 처리한 후에 반환할 뷰의 이름을 반환한다. - 커맨드 객체를 생성하고 요청 데이터를 객체 필드에 바인딩
6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
8. 데이터가 추가된 뷰를 반환한다.

# 제어의 역전 (IoC, Inversion of Control) 이란
+ 제어의 역전이란 모든 객체에 대한 (생성, 라이프 사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것
+ 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
+ 컨테이너에 등록한 객체들을 '빈'이라고 한다.

# IoC 컨테이너 (Inversion of Control) 이란
+ 제어의 역전 원칙을 구현하는 프레임워크의 핵심 구성 요소. 주로 객체의 생성과 의존성 관리 담당
+ Bean을 생성하고 관리하며 객체 간의 의존성 주입

# 스프링에서 빈(Bean)을 등록하는 방법
+ @Component 어노테이션 사용
+ 설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고, 해당 클래스 안에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성됨

# 의존성 주입 (DI, Dependency Injection) 이란
+ 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 ㅅ아요하는 것
+ 이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있음
+ 의존성 주입은 생성자 주입, 필드 주입, 세터 주입 3가지 방법이 있다. Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법이다.
+ 그 이유는 1. 순환 참조를 방지 2. 불변성을 가짐 3. 테스트에 용이하기 때문

# 스프링 Bean의 LifeCycle
+ 스프링 IoC컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 메서드 호출 -> 사용 -> 소멸 전 콜백 메소드 호출 -> 스프링 종료
+ 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리함
1. 인터페이스 (InitializingBean, DisposableBean)
2. 설정 정보에 초기화 메소드, 종료 메소드 지정
3. @PostConstruct, @PreDestroy 어노테이션 지원

# SpringFilter와 Interceptor에 대한 설명과 사용 예시
+ 필터는 요청과 응답을 거른 뒤 정제하는 역할
+ 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리됨
+ Dispather Servlet에 요청이 전달되기 전 / 후에 url 패턴에 마즌ㄴ 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
사용 사례
1. 보안 및 인증 / 인가 관련 작업
2. 모든 요청에 대한 로깅 또는 검사
3. 이미지 / 데이터 압축 및 문자열 인코딩
4. Spring과 분리되어야 하는 기능

+ 인터셉터는 요청에 대한 작업 전 / 후로 가로채 요청과 응답을 참조하거나 가공하는 역할
+ 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작
+ Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
사용사례
1. 세부적인 보안 및 인증 / 인가 공통 작업
2. API 호출에 대한 로깅 또는 검사
3. Controller로 넘겨주는 정보(데이터)의 가공

# 관점지향 프로그래밍(AOP, Aspect Oriented Programming) 이란
+ AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며, 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이
+ 핵짐 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있음
+ AOP의 가장 큰 특징이자 장점은 중복 코드 제거, 재활용성의 극대화, 변수활용의 용이성이 좋다는 점

# Lombok 라이브러리와 롬복이 만드는 메소드들이 생성되는 시점 ?
+ Lombox은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어낸다. 이것을 어노테이션 프로세싱이라고 한다.
+ 어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 분석하고 처리하는 기법을 말한다.
	- Lombok 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.

# 서블릿(Servlet) 이란
+ 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
+ Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환한다.
+ 자바를 사용해 웹을 맏늘기 위해 필요한 기술

# VO, BO, DAO, DTO 설명
+ DAO (Data Access Object) 는 DB의 데이터에 접근을 위한 객체 (Repository 또는 Mapper에 해당)
+ BO (Business Object) 는 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체 (Service 에 해당)
+ DTO (Data Transfer Object) 는 각 계층간의 데이터 교환을 위한 객체 (Controller, View, Business Layer, Persistent Layer)
+ VO (Value Object) 는 실제 데이터만을 저장하는 객체

# Spring의 싱글톤 패턴
+ 스프링에서 bean 생성 시 별다른 설정이 없으면 default로 싱글톤이 적용된다.
+ 스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 
+ 요청이 들어올 때마다 매번 객체를 생성하지 않고 이미 만들어진 객체를 공유하기 때문에 효율적으로 사용이 가능하다.
+ 장점
	- static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
	- 테스트하기 편리

# Spring의 스코프 프로토 타입 빈이란
+ 프로토타입 빈은 싱글톤 빈(default bean)과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새롱룬 객체를 생성하여 반환한다.
+ 이렇게 빈의 scope를 간단하게 관리해줄 수 있는 것이 spring의 장점
+ 빈의 scope 설정은 @Scope 어노테이션으로 설정하며, 프로토타입 scope로 설정하려면 @Scope("prototype")와 같이 문자열로 지정해준다.

# Transactional 의 동작 원리
+ @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며,
+ Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행한다.

# A라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개 (다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)
# 가 존재한다고 할 때, @Transactional을 A메소드에 적용하면 어떤 요청 흐름이 발생하는지?
+ 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행된다.
+ 그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 된다.

# @Transactional에 readOnly 속성을 사용하는 이유
+ 트랜잭션 안에서 수정/삭제 작업이 아닌 ReadOnly 목적인 경우에 주로 사용하며,
+ 영속성 컨텍스트에서 엔티티를 관리할 필요가 없기 때문에 readOnly를 추가하는 것으로 메모리 성능을 높일 수 있고,
+ 데이터 변경 불가능 로직임을 코드로 표시할 수 있어 가독성이 높아진다는 장점이 있다.
	- readOnly 속성이 없는 보통의 트랜잭션은 데이터 조회 결과 엔티티가 영속성 컨텍스트에 관리되며, 
	- 이는 1차 캐싱부터 변경 감지(Dirty Checking)까지 가능하게 된다.
	- 하지만, 조회시 스냅샷 인스턴스를 생성해 보관하기 때문에 메모리 사용량이 증가한다.

# JPA N + 1 문제와 발생하는 이유, 해결 방법
+ N + 1이란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미
+ 해결 방법중 많이 사용되는 방법은 Fetch Join을 사용하는 방법
+ N + 1 문제가 발생하는 이유는 연관관계를 가진 엔티티를 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문인데,
+ Fetch Join을 사용하면 미리 두 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 N+1 무제를 애초에 막을 수 있따.

# JAP와 같은 ORM을 사용하면서 쿼리가 보갖ㅂ해지는 경우의 해결방법
+ JPA는 정적인 상황에서 사용하는 걸 권장하기 때문에 복잡한 쿼리와 동적인 쿼리에 대한 문제가 발생하게 되는데, 그런 경우엔 JPQL과 Querysl을 사용하면 된다.



















































