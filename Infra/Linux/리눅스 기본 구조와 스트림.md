리눅스는 모든 것을 파일로 다루는 운영체제다.

디스크, 장치, 설정, 실행 파일까지 하나의 트리 구조로 관리된다.


최상위 디렉토리는 루트 디렉토리( / )이며, 그 아래로 역할별 디렉토리가 나뉜다.

주요 디렉토리
경로	설명
/	모든 디렉토리와 파일의 최상위 루트(root)
절대 경로의 시작점
/bin	기본적인 사용자 명령어 저장
/sbin	시스템 관리용 명령어 저장
root 권한에서 주로 사용
/etc	시스템 설정 파일 저장
서비스 설정, 네트워크 설정, 계정 관련 파일 존재
/home	일반 사용자들의 홈 디렉토리
ex) /home/user
/root	root 계정 홈 디렉토리
/home 아래가 아닌 별도 경로로 존재
/var	시스템 운영 중 계속 변하는 데이터 저장
로그 (/var/log)
캐시, 메일, 스풀 데이터 등
/usr	사용자 프로그램과 라이브러리
/usr/bin, /usr/lib, /usr/include 등 포함
읽기 전용 구조에 가까움
/lib, /lib64	커널과 프로그램에 실행에 필요한 공유 라이브러리
부팅 시 필수 라이브러리 포함
/tmp	임시 파일 저장 공간
재부팅 시 삭제되는 경우 많음
/dev	디바이스 파일 저장
하드웨어를 파일처럼 다루는 리눅스 구조
ex) /dev/sda, /dev/null
/proc	실행중인 프로세스 및 커널 정보
실제 디스크가 아닌 메모리 기반 가상 파일 시스템
/sys	커널 및 하드웨어 상태 정보 제공
/proc보다 구조화된 시스템 정보
/boot	부트로더와 커널 이미지 저장
리눅스 부팅에 직접 관여
/opt	추가 설치한 소프트웨어 위치
서드파티 프로그램 자주 설치됨
/mnt	임시 마운트 지점
외장 디스크나 ISO 연결할 때 사용
/media	USB, CD-ROM 같은 이동식 장치 자동 마운트
/run	시스템 부팅 후 생성되는 런타임 데이터

자주 사용하는 명령어

pwd # 현재 위치 확인 (절대경로)

mkdir [dir1] [dir2] # 디렉토리 생성

ls # 파일 리스트 조회
  -alh # 숨긴 파일 및 파일 사이즈 조회

cd [이동할 디렉토리] # 디렉토리 이동

cp [원본파일] [대상 위치] # 디렉토리 / 파일 복사
cp [원본파일] [위치와 파일명] # 다른 이름으로 복사
  -r [원본위치] [대상위치] # 디렉토리로 복사
  -r [원본위치]. # 현재 디렉토리로 복사
	
mv # 디렉토리 / 파일 이동 + 이름변경

rm # 디렉토리 / 파일 삭제
  -r # 재귀삭제
  -f # 강제삭제

touch [파일명] # 파일 생성 (.파일명 => 숨긴 파일)

tree # 디렉토리 구조 확인
  -d # 디렉토리만 조회
  -a # 숨긴파일까지 조회
  -L [깊이] [디렉토리] # 깊이 지정 조회
  -P #일치하는 패턴만 조회
  -l # 일치하는 패턴 제외 후 조회
    
mv [원본 위치] [새 위치] # 파일/디렉토리 이동

find [찾을 위치] -name [파일/디렉토리 명] # 파일/디렉토리 찾기

rm [삭제할 파일 위치] # 파일 삭제
  -r [삭제할 디렉토리 위치] # 디렉토리 삭제
  -rf [삭제할 파일 위치] # 파일 강제 삭제

cat # 파일의 내용 화면에 출력

표준 스트림
번호	이름	설명
0	표준 입력 (stdin)	키보드 입력
1	표준 출력 (stdout)	정상 출력
2	표준 에러 (stderr)	에러 출력

리다이렉션이란

리눅스에서는 명령어 실행 결과를 기본적으로 터미널 화면에 출력하지만,

사용자가 출력 방향을 파일이나 다른 위치로 변경할 수 있는데 이를 리다이렉션(Redirection) 이라고 한다.


리다이렉션은 기본적으로 표준 출력(stdout) 을 대상으로 동작하며,

에러 메시지(stderr)까지 함께 저장하고 싶다면 스트림 번호를 명시해야 한다.

command > file.txt 2>&1

위 명령은 일반 출력(stdout)을 file.txt로 보내고,

에러 출력(stderr)을 일반 출력으로 합쳐 동일한 파일에 저장한다.

command &> file.txt

&> 는 일반 출력과 에러 출력을 동시에 리다이렉션하는 간단한 표현이다.


    리다이렉션 & 파이프

기호	의미	예시
>	출력 덮어쓰기	ls > list.txt
# ls 결과를 list.txt 에 새로 저장 (기존 내용 삭제)
>> 	출력 추가	ls >> list.txt
# 기존 파일 뒤에 결과 추가
<	입력 받기	sort < names.txt
# names.txt 내용을 sort 입력으로 사용
<<	여러 줄 입력	cat << EOF
hello
linux
EOF
# EOF까지 입력한 내용을 cat으로 출력
2>	에러 출력	ls nofile 2> error.txt
# 에러 메시지만 error.txt로 저장
2>>	에러 추가	ls nofile 2>> error.txt
# 에러를 기존 파일 뒤에 추가
2>&1	에러를 일반 출력으로 합치기	ls test nofile > all.txt 2>&1
# 정상 출력 + 에러 출력 전부 all.txt에 저장﻿
&>	일반출력 + 에러출력 리다이렉션	ls test nofile &> all.txt
# 위와 같은 의미
|	파이프 (명령어 연결)	ls | grep txt
# ls 결과를 grep의 입력으로 전달

입출력 활용

        ps aux > ps.txt
        ps aux 명령의 출력 을 ps.txt 파일에 저장합니다.
        head < ps.txt
        head 명령의 입력 을 ps.txt 파일에서 가져옵니다.
        head < ps.txt > sample.txt
        head 명령의 입력 을 ps.txt 파일에서 가져오고, sample.txt 파일에 저장합니다.

파이프 |


| : 출력 -> 다음 명령 입력

ps aux | grep java


ps 출력 -> grep 입력


에러 개수 세기

cat log.txt | grep ERROR | wc - l


출력 버리기

/dev/null

ls test 2> /dev/null

에러 출력 무시








[Linux] 내가 보려고 만든 리눅스 명령어

🐧 리눅스를 사용하는 이유 개발자들은 왜 리눅스와 친할까요? 리눅스와 타 OS들의 차이들을 살펴볼게요. 윈도우, 맥OS, 그리고 모바일의안드로이드, iOS등은 모두일반인, 즉 개발자가 아닌 사람

hyonyong.tistory.com


