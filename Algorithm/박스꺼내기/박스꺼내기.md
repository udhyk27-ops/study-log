처음에는 상자들이 층별로 쌓여 있는 모습이 2차원 구조처럼 보여서, 자연스럽게 2차원 배열을 만들어 풀어보려고 했다. 

 

하지만 구현을 하다 보니 배열 크기를 계산해야 하고, 층마다 방향이 바뀌는 지그재그 처리도 생각보다 번거로워서 상자의 번호를 기준으로 층과 열 위치를 계산하는 방식이 더 간단하다는 걸 알게 됐다.

 

결국 2차원 배열로도 풀 수는 있었지만, 메모리 사용이나 가독성을 생각했을 때 번호 규칙을 이용해 위치를 계산하는 방법이 더 적잡한 방법이라고 생각했다.

 

    문제풀이 - 2차원 배열

class Solution {
    public int solution(int n, int w, int num) {

        int rows = (n + w - 1) / w;
        int[][] boxes = new int[rows][w];

        int value = 1;

        // 상자 쌓기
        for (int i = 0; i < rows; i++) {
            if (i % 2 == 0) {
                for (int j = 0; j < w && value <= n; j++) {
                    boxes[i][j] = value++;
                }
            } else {
                for (int j = w - 1; j >= 0 && value <= n; j--) {
                    boxes[i][j] = value++;
                }
            }
        }

        // num 위치 찾기
        int targetRow = 0, targetCol = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < w; j++) {
                if (boxes[i][j] == num) {
                    targetRow = i;
                    targetCol = j;
                }
            }
        }

        // 위에 있는 상자 개수
        int answer = 0;
        for (int i = targetRow; i < rows; i++) {
            if (boxes[i][targetCol] != 0) {
                answer++;
            }
        }

        return answer;
    }
}

    참고풀이 - 번호 계산

class Solution {
    public int solution(int n, int w, int num) {

        // num의 위치 구하기
        int targetRow = (num - 1) / w;
        int targetCol = (num - 1) % w;

        // 지그재그 보정
        if (targetRow % 2 == 1) {
            targetCol = w - 1 - targetCol;
        }

        int count = 0;

        // num부터 n까지 검사
        for (int i = num; i <= n; i++) {

            int row = (i - 1) / w;
            int col = (i - 1) % w;

            // 지그재그 보정
            if (row % 2 == 1) {
                col = w - 1 - col;
            }

            // 같은 열이면 위에 있는 박스
            if (col == targetCol) {
                count++;
            }
        }

        return count;
    }
}

 

    다른 사람의 문제풀이

import java.util.*;

class Solution {
    public int solution(int n, int w, int num) {
        int cnt = 0;
        while(num <= n) {
            num += (w - ((num-1) % w) -1) * 2 + 1;
            cnt++;
        }
        
        int answer = cnt;
        return answer;
    }
}

현재 열 위치: (num - 1) % w

다음 층의 같은 세로 위치로 이동하는 거리: (w - col - 1) * 2 + 1

위에 몇개 있는지 개수 세기: while(num <= n)

 

상자의 번호 증가 규칙을 수열처럼 계산하여 같은 세로 위치의 상자를 찾아가는 방식으로 해결한 것인데 불필요한 계산 없이 필요한 위치만 찾아가는 깔끔한 접근이라고 느꼈다.